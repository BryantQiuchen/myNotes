## 虚函数和派生

```cpp
class A {
public:
    virtual void F() { cout << 1 << endl; }
    void callF() { F(); }
    virtual ~A() {
        callF();
        F();
    }
};

class B : public A {
public:
    void F() { cout << 3 << endl; }
    void callF() {
        F();
        A::callF();
    }
    virtual ~B() { callF(); };
};

int main() {
    A *p = new B();
    p->callF();
    delete p;
    return 0;
}
```

上述代码运行结果？

3 3 3 1 1

1. 对于`A *p = new B();`，虽然 p 是一个基类的指针，但`new B()`调用的是派生类B的构造方法，所有构造的是B类的对象，首先调用基类A的构造函数，再调用B的构造函数，构造完后会返回B类对象的地址，将它赋值给基类指针p。
2. 调用`p->callF();`，调用A中的`callF()`函数，由于是A中的`F()`是虚函数，所以会调用B的`F()`方法。
3. `delete p;`，首先调用B的析构函数，调用`~B()`中的`callF()`方法，输出第二个3，再调用`A::call()`，A中的`F()`为虚函数，所以调用B的`F()`，输出第三个3，至此B的析构函数执行完；接着执行A的析构函数，由于B已经调用了析构函数，所以会输出1 1。