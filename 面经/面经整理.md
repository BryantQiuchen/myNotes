# C++基础

## C++从代码到可执行二进制文件经历的过程

一个C++程序从源码到执行文件，有四个过程，预编译、编译、汇编、链接

1. 预编译：这个过程主要的处理操作如下：

    （1） 将所有的#define删除，并且展开所有的宏定义

    （2） 处理所有的条件预编译指令，如#if、#ifdef

    （3） 处理#include预编译指令，将被包含的文件插入到该预编译指令的位置。

    （4） 过滤所有的注释

    （5） 添加行号和文件名标识。

2. 编译：这个过程主要的处理操作如下：

    （1） 词法分析：将源代码的字符序列分割成一系列的记号。

    （2） 语法分析：对记号进行语法分析，产生语法树。

    （3） 语义分析：判断表达式是否有意义。

    （4） 代码优化：

    （5） 目标代码生成：生成汇编代码。

    （6） 目标代码优化：

3. 汇编：这个过程主要是将汇编代码转变成机器可以执行的指令。

4. 链接：将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。

    链接分为静态链接和动态链接。

    静态链接，是在链接的时候就已经把要调用的函数或者过程链接到了生成的可执行文件中，就算你在去把静态库删除也不会影响可执行程序的执行；生成的静态链接库，Windows下以.lib为后缀，Linux下以.a为后缀。

    而动态链接，是在链接的时候没有把调用的函数代码链接进去，而是在执行的过程中，再去找要链接的函数，生成的可执行文件中没有函数代码，只包含函数的重定位信息，所以当你删除动态库时，可执行程序就不能运行。生成的动态链接库，Windows下以.dll为后缀，Linux下以.so为后缀。

## new和malloc的区别

1. new是操作符，而malloc是函数。
2. new在**调用的时候先分配内存，在调用构造函数，释放的时候调用析构函数**；而malloc没有构造函数和析构函数。
3. malloc需要给定申请内存的大小，返回的指针需要强转；new会调用构造函数，不用指定内存的大小，返回指针不用强转。
4. new可以被重载；malloc不行
5. new分配内存更直接和安全。
6. new发生错误抛出异常，malloc返回null

## const

```cpp
const int a;	// a是一个常量
const int* a;	// a是一个指针，指向一个常量(*a)，不能通过指针修改其指向的内容，但可					以改变指针本身所指向的地址
int const *a;	// 同上
int *const a;	// a是一个常量指针，指向一个int，可以通过指针改变其指向的内容，不可以					改变指向的地址，只能指向该地址
const int *const a;	// a是一个常量指针，指向一个常量，不可改变指针指向的内容也不可以						通过指针改变其指向的内容
int const *const a;	// 同上
```

## c++传值的方式

1. 值传递：形参即使在函数体内值发生变化，也不会影响实参的值；
2. 引用传递：形参在函数体内值发生变化，会影响实参的值；
3. 指针传递：在指针指向没有发生改变的前提下，形参在函数体内值发生变化，会影响实参的值；

## 堆和栈的区别

1. **堆栈空间分配不同**。栈由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等；堆一般由程序员分配释放。
2. **堆栈缓存方式不同**。栈使用的是一级缓存， 它们通常都是被调用时处于存储空间中，调用完毕立即释放；堆则是存放在二级缓存中，速度要慢些。
3. **堆栈数据结构不同**。堆类似数组结构；栈类似栈结构，先进后出。

## C++内存分配方式

在C++中，内存分成5个区，他们分别是堆、栈、自由存储区、全局/静态存储区和常量存储区。

- **栈**，在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。
- **堆**，就是那些由new分配的内存块，一般一个new就要对应一个delete。

- **自由存储区**，就是那些由malloc等分配的内存块，和堆是十分相似的，不过是用free来结束自己的生命。

- **全局/静态存储区**，全局变量和静态变量被分配到同一块内存中

- **常量存储区**，这是一块比较特殊的存储区，里面存放的是常量，不允许修改。

## 面向对象的三大特征

封装、继承、多态

1. 封装：将数据和操作数据的方法进行有机结合，隐藏对象的属性和实现细节，仅对外公开接口来和对象进行 交互。类也是一样，不想给别人看到的，我们使用protected/private把成员封装起来。开放一些共有的成员函数对成员合理的访问。

2. 继承：可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。

    三种继承方式

    | 继承方式            | private继承     | protected继承     | public继承                   |
    | :------------------ | :-------------- | :---------------- | :--------------------------- |
    | 基类的private成员   | 不可见          | 不可见            | 不可见                       |
    | 基类的protected成员 | 变为private成员 | 仍为protected成员 | 仍为protected成员            |
    | 基类的public成员    | 变为private成员 | 变为protected成员 | 仍为public成员仍为public成员 |

3. 多态：用父类型别的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。实现多态，有二种方式，重写，重载。

## STL的基本组成部分

  标准模板库STL主要由6大组成部分：

1. 容器 (Container)  

      是一种数据结构， 如list, vector, 和deques，以模板类的方法提供。为了访问容器中的数据，可以使用由容器类输出的迭代器。

2. 算法（Algorithm）

      是用来操作容器中的数据的模板函数。例如，STL用sort()来对一 个vector中的数据进行排序，用find()来搜索一个list中的对象， 函数本身与他们操作的数据的结构和类型无关，因此他们可以用于从简单数组到高度复杂容器的任何数据结构上。

3. 迭代器（Iterator）

      提供了访问容器中对象的方法。例如，可以使用一对迭代器指定list或vector中的一定范围的对象。 迭代器就如同一个指针。事实上，C++ 的指针也是一种迭代器。 但是，迭代器也可以是那些定义了operator*()以及其他类似于指针的操作符方法的类对象;

4. 仿函数（Function object）

      仿函数又称之为函数对象， 其实就是重载了操作符的struct,没有什么特别的地方。

5. 适配器（Adaptor）

      简单的说就是一种接口类，专门用来修改现有类的接口，提供一中新的接口；或调用现有的函数来实现所需要的功能。主要包括3中适配器Container Adaptor、Iterator Adaptor、Function Adaptor。

6. 空间配制器（Allocator）

      为STL提供空间配置的系统。其中主要工作包括两部分：

    （1）对象的创建与销毁；

    （2）内存的获取与释放。

## push_back 和 emplace_back 的区别

如果要将一个临时变量push到容器的末尾，push_back()需要先构造临时对象，再将这个对象拷贝到容器的末尾，而emplace_back()则直接在容器的末尾构造对象，这样就省去了拷贝的过程。

# 数据结构

## **为什么有了二叉查找树/平衡树还需要红黑树**

红黑树通过如下性质来定义实现自平衡：

- 节点是红色或黑色

- 根是黑色

- 每个叶子都是黑子（指为空的叶子节点）

    ![截屏2022-04-15 上午10.35.37](/Users/ryan/Documents/notes/images/cppNotes/截屏2022-04-15 上午10.35.37.png)

- 如果一个节点是红色的，则它的子节点必须是黑色的（每个叶子到根的所有路径上不能有两个连续的红色节点）

- ==从任一节点到其叶子节点的简单路径都包含相同数目的黑色节点==（简称黑高）

平衡树是为了解决二叉查找树退化为链表的情况，而红黑树是为了解决平衡树在插入、删除等操作需要频繁调整的情况。