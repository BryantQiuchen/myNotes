# 网络整理

## socket 编程过程

基于TCP(面向连接)的socket编程的**服务器端**程序如下：

- 创建套接字（socket）
- 将套接字绑定到一个本地地址和端口上（bind）
- 将套接字设为监听模式，准备接收客户端请求（listen）
- 等待客户请求到来，当请求到来后，接收连接请求，返回一个新的对应于此次连接的套接字（accept）
- 用返回的套接字和客户端进行通信（send/recv）返回，等待另一客户请求
- 关闭套接字

基于TCP(面向连接)的socket编程的**客户端**程序如下：

- 创建套接字（socket）
- 向服务器发出连接请求（connect）
- 和服务器端进行通信（send/recv）
- 关闭套接字

基于UDP(面向对象)的socket编程的**服务器端**程序如下：

- 创建套接字（socket）
- 将套接字绑定到一个本地地址和端口上（bind）
- 等待接收数据（recvfrom）
- 关闭套接字

基于UDP(面向对象)的socket编程的**客户端**程序如下：

- 创建套接字（socket）
- 向服务器发送数据（sendto）
- 关闭套接字

## tcp 和 udp 的区别

1. TCP是可靠传输，UDP是不可靠传输；
2. TCP是面向连接的（连接需要经过三次握手，断开连接需要经过四次挥手），UDP是无连接的；
3. TCP是面向字节流（当用户消息通过 TCP 协议传输时，**消息可能会被操作系统分组成多个的 TCP 报文**，也就是一个完整的用户消息被拆分成多个 TCP 报文进行传输。），UDP是面向报文的（通过UDP传输数据，操作系统不会对消息进行拆分，组装好UDP头部后就交给网络层处理，每个UDP报文就是完整的用户消息；
4. TCP传输数据有序，UDP不保证数据的有序性；
5. 每一条TCP连接只能是点对对连接的，UDP支持一对一、一对多、多对一和多对多；
6. TCP首部开销20字节;UDP的首部开销小，只有8个字节。

## 线程通信的方式

线程间的通信目的主要是用于线程同步

线程同步：当有⼀个线程在对内存进⾏操作时，其他线程都不可以对这个内存地址进⾏操作，直 到该线程完成操作，其他线程才能对该内存地址进⾏操作，⽽其他线程则处于等待状态。

锁机制

- ==互斥锁==确保同一时间只能有一个线程访问共享资源。当锁被占用时试图对其加锁的线程都进入阻塞状态(释放CPU资源使其由运行状态进入等待状态)。当锁释放时哪个等待线程能获得该锁取决于内核的调度。

- ==读写锁==当以写模式加锁而处于写状态时任何试图加锁的线程(不论是读或写)都阻塞，当以读状态模式加锁而处于读状态时“读”线程不阻塞，“写”线程阻塞。读模式共享，写模式互斥。

- ==条件变量==可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。

- ==自旋锁==上锁受阻时线程不阻塞而是在循环中轮询查看能否获得该锁，没有线程的切换因而没有切换开销，不过对CPU的霸占会导致CPU资源的浪费。 所以自旋锁适用于并行结构(多个处理器)或者适用于锁被持有时间短而不希望在线程切换产生开销的情况。

信号量

信号量实际上是一个非负的整数计数器，用来实现对公共资源的控制。在公共资源增加的时候，信号量就增加；公共资源减少的时候，信号量就减少；只有当信号量的值大于0的时候，才能访问信号量所代表的公共资源。

## 虚函数和虚函数表

多态通过虚函数来实现，**编译器中主要用虚表指针（vptr）和虚函数表（vtbl）来实现虚函数**

当调用一个对象对应的函数时，通过对象内存中的 vptr 找到一个虚函数表（注意这虚函数表既不在堆上，也不再栈上）。虚函数表内部是一个函数指针数组，记录的是该类各个虚函数的首地址。然后调用对象所拥有的函数。

## 谈一谈new/delete和malloc/free的区别和联系

联系：

都用于申请动态内存和释放动态内存

区别：

- malloc/free 是 C++/C 语言标准库函数，而 new/delte 是 C++ 的运算符。malloc 仅仅只分配内存，而不会进行初始化类成员的工作，new 不止分配内存，而且还是调用类的构造函数。
- new操作符申请内存的时候不需要指定内存块的大小，编译器会自动根据类型信息来计算，malloc需要显示的指出内存的大小。
- new 运算符从自由存储区上为对象动态分配内存空间。（new 所申请的内存区域也是在堆上），malloc 从堆上动态分配内存。

> 自由存储区和堆之间的相关问题:
>
> 在 C++ 中内存分为5个区，分别是堆、栈、自由存储区、全局/静态存储区、常量区。
>
> 堆和自由存储区都是 C++ 语言中的两块动态存储区域。但是我从这两块存储区申请的方式是有别的。比如对于自由存储区，必须用new和delete来存储和释放，对于堆中的内存必须用 malloc 和 free 来存储和释放。
>
> 堆是c语言和操作系统中的术语，是操作系统所维护的一块特殊的内存空间，提供了动态分配内存的功能。而自由存储区是c++这门语言自定义的一个抽象概念。因此c++也是使用堆来实现自由存储的，operator new的源码中也用的malloc和free来实现自由存储的。
>
> 总结：堆是一个物理概念，操作系统实实在在给你的东西。而自由存储区是一个逻辑概念。

# 简历基础知识

## TCP 三次握手

1. 第一次握手：客户端给服务器发送一个 SYN 报文。
2. 第二次握手：服务器收到 SYN 报文之后，会应答一个 SYN+ACK 报文。
3. 第三次握手：客户端收到 SYN+ACK 报文之后，会回应一个 ACK 报文。
4. 服务器收到 ACK 报文之后，三次握手建立完成。

## TCP 四次挥手

1. 第一次挥手：客户端希望关闭连接，给服务端发送 FIN 报文，客户端处于 FIN_WAIT1 状态
2. 第二次挥手：服务端收到 FIN 后，发送 ACK 报文，表明已经收到客户端传输的报文了，此时服务端处于 CLOSE_WAIT 状态
3. 第三次挥手：如果服务端也希望断开连接，和客户端第一次挥手一样，发送 FIN 报文，指定一个序列号，服务端处于 LASK_ACK 状态
4. 第四次挥手：客户端收到 FIN 之后，发送 ACK 报文作为应答，客户端处于 TIME_WAIT 状态。需要过一阵子确保服务端收到自己的 ACK 报文后才会进入 CLOSED 状态
5. 服务端收到 ACK 报文后，就关闭连接

## TCP 流量控制



## TCP 拥塞控制

慢启动，加性增，乘性减

## I/O 复用技术