# 网络整理

## socket 编程过程

基于TCP(面向连接)的socket编程的**服务器端**程序如下：

- 创建套接字（socket）
- 将套接字绑定到一个本地地址和端口上（bind）
- 将套接字设为监听模式，准备接收客户端请求（listen）
- 等待客户请求到来，当请求到来后，接收连接请求，返回一个新的对应于此次连接的套接字（accept）
- 用返回的套接字和客户端进行通信（send/recv）返回，等待另一客户请求
- 关闭套接字

基于TCP(面向连接)的socket编程的**客户端**程序如下：

- 创建套接字（socket）
- 向服务器发出连接请求（connect）
- 和服务器端进行通信（send/recv）
- 关闭套接字

基于UDP(面向对象)的socket编程的**服务器端**程序如下：

- 创建套接字（socket）
- 将套接字绑定到一个本地地址和端口上（bind）
- 等待接收数据（recvfrom）
- 关闭套接字

基于UDP(面向对象)的socket编程的**客户端**程序如下：

- 创建套接字（socket）
- 向服务器发送数据（sendto）
- 关闭套接字

## tcp 和 udp 的区别

1. TCP是可靠传输，UDP是不可靠传输；
2. TCP是面向连接的（连接需要经过三次握手，断开连接需要经过四次挥手），UDP是无连接的；
3. TCP是面向字节流（当用户消息通过 TCP 协议传输时，**消息可能会被操作系统分组成多个的 TCP 报文**，也就是一个完整的用户消息被拆分成多个 TCP 报文进行传输。），UDP是面向报文的（通过UDP传输数据，操作系统不会对消息进行拆分，组装好UDP头部后就交给网络层处理，每个UDP报文就是完整的用户消息；
4. TCP传输数据有序，UDP不保证数据的有序性；
5. 每一条TCP连接只能是点对对连接的，UDP支持一对一、一对多、多对一和多对多；
6. TCP首部开销20字节;UDP的首部开销小，只有8个字节。

## 线程通信的方式

线程间的通信目的主要是用于线程同步

线程同步：当有⼀个线程在对内存进⾏操作时，其他线程都不可以对这个内存地址进⾏操作，直 到该线程完成操作，其他线程才能对该内存地址进⾏操作，⽽其他线程则处于等待状态。

锁机制

- ==互斥锁==确保同一时间只能有一个线程访问共享资源。当锁被占用时试图对其加锁的线程都进入阻塞状态(释放CPU资源使其由运行状态进入等待状态)。当锁释放时哪个等待线程能获得该锁取决于内核的调度。

- ==读写锁==当以写模式加锁而处于写状态时任何试图加锁的线程(不论是读或写)都阻塞，当以读状态模式加锁而处于读状态时“读”线程不阻塞，“写”线程阻塞。读模式共享，写模式互斥。

- ==条件变量==可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。

- ==自旋锁==上锁受阻时线程不阻塞而是在循环中轮询查看能否获得该锁，没有线程的切换因而没有切换开销，不过对CPU的霸占会导致CPU资源的浪费。 所以自旋锁适用于并行结构(多个处理器)或者适用于锁被持有时间短而不希望在线程切换产生开销的情况。

信号量

信号量实际上是一个非负的整数计数器，用来实现对公共资源的控制。在公共资源增加的时候，信号量就增加；公共资源减少的时候，信号量就减少；只有当信号量的值大于0的时候，才能访问信号量所代表的公共资源。

## 虚函数和虚函数表

多态通过虚函数来实现，**编译器中主要用虚表指针（vptr）和虚函数表（vtbl）来实现虚函数**

当调用一个对象对应的函数时，通过对象内存中的 vptr 找到一个虚函数表（注意这虚函数表既不在堆上，也不再栈上）。虚函数表内部是一个函数指针数组，记录的是该类各个虚函数的首地址。然后调用对象所拥有的函数。

## 谈一谈new/delete和malloc/free的区别和联系

联系：

都用于申请动态内存和释放动态内存

区别：

- malloc/free 是 C++/C 语言标准库函数，而 new/delte 是 C++ 的运算符。malloc 仅仅只分配内存，而不会进行初始化类成员的工作，new 不止分配内存，而且还是调用类的构造函数。
- new操作符申请内存的时候不需要指定内存块的大小，编译器会自动根据类型信息来计算，malloc需要显示的指出内存的大小。
- new 运算符从自由存储区上为对象动态分配内存空间。（new 所申请的内存区域也是在堆上），malloc 从堆上动态分配内存。

> 自由存储区和堆之间的相关问题:
>
> 在 C++ 中内存分为5个区，分别是堆、栈、自由存储区、全局/静态存储区、常量区。
>
> 堆和自由存储区都是 C++ 语言中的两块动态存储区域。但是我从这两块存储区申请的方式是有别的。比如对于自由存储区，必须用new和delete来存储和释放，对于堆中的内存必须用 malloc 和 free 来存储和释放。
>
> 堆是c语言和操作系统中的术语，是操作系统所维护的一块特殊的内存空间，提供了动态分配内存的功能。而自由存储区是c++这门语言自定义的一个抽象概念。因此c++也是使用堆来实现自由存储的，operator new的源码中也用的malloc和free来实现自由存储的。
>
> 总结：堆是一个物理概念，操作系统实实在在给你的东西。而自由存储区是一个逻辑概念。

## 指针和引用的区别

指针是一个对象，而引用是被引用对象的别名。

引用定义后必须被初始化，指针不必。

引用在定义后不能被改变，但指针可以改变所指的对象

## C++ 三大特性

封装：抽象为类和类的方法，并且可以对信息通过 private 修饰来进行隐藏

继承：已有类产生新类的过程，原有类为父类，新产生的类为派生类，让派生类获得基类的属性和方法。

多态：覆盖和重载

## 项目中为什么不用多进程，要用多线程



## 进程的通信方式有哪些。管道通信与socket通信的区别又问管道通信与消息队列通信方式的区别



# 简历基础知识

## OSI 七层模型

应用层

表示层

会话层

传输层

网络层

数据链路层

物理层

## TCP 三次握手

1. 第一次握手：客户端给服务器发送一个 SYN 报文。
2. 第二次握手：服务器收到 SYN 报文之后，会应答一个 SYN+ACK 报文。
3. 第三次握手：客户端收到 SYN+ACK 报文之后，会回应一个 ACK 报文。
4. 服务器收到 ACK 报文之后，三次握手建立完成。

## TCP 四次挥手

1. 第一次挥手：客户端希望关闭连接，给服务端发送 FIN 报文，客户端处于 FIN_WAIT1 状态
2. 第二次挥手：服务端收到 FIN 后，发送 ACK 报文，表明已经收到客户端传输的报文了，此时服务端处于 CLOSE_WAIT 状态
3. 第三次挥手：如果服务端也希望断开连接，和客户端第一次挥手一样，发送 FIN 报文，指定一个序列号，服务端处于 LASK_ACK 状态
4. 第四次挥手：客户端收到 FIN 之后，发送 ACK 报文作为应答，客户端处于 TIME_WAIT 状态。需要过一阵子确保服务端收到自己的 ACK 报文后才会进入 CLOSED 状态
5. 服务端收到 ACK 报文后，就关闭连接

## TCP 流量控制

TCP 提供一种机制让发送方根据接收方的实际接收能力控制发送的数据量，这就是所谓的流量控制。

滑动窗口

## TCP 拥塞控制

慢启动：当发送方每收到一个 ACK，拥塞窗口`cwnd`大小加1（指数增长）

拥塞避免：当拥塞窗口`cwnd`「超过」慢启动门限`ssthresh`就会进入拥塞避免算法。每收到一个 ACK 时，拥塞窗口大小加 1/cwnd（线性增长）

拥塞发生：

- 超时重传：门限设置为cwnd/2，cwnd重置为1
- 快速重传（收到三个重复的 ACK）：cwnd=cwnd/2，门限设置为cwnd，进入快速恢复

快速恢复：cwnd=ssthresh+3，加性增加

## DNS

正向解析（域名解析为IP地址）

1. 搜索浏览器的 DNS 缓存，缓存中维护一张域名与 IP 地址的对应表
2. 没有命中查询操作系统的DNS缓存
3. 若仍然没有命中，则操作系统将域名发送至**本地域名服务器**，本地域名服务器查询自己的 DNS 缓存，查找成功则返回结果（注意：主机和本地域名服务器之间的查询方式是**递归查询**）；
4. 若本地域名服务器的 DNS 缓存没有命中，则本地域名服务器向上级域名服务器进行查询（迭代查询）
    - 首先本地域名服务器向**根域名服务器**发起请求，根域名服务器是最高层次的，它并不会直接指明这个域名对应的 IP 地址，而是返回顶级域名服务器的地址，也就是说给本地域名服务器指明一条道路，让他去这里寻找答案
    - 本地域名服务器拿到这个**顶级域名服务器**的地址后，就向其发起请求，获取**权限域名服务器**的地址
    - 本地域名服务器根据权限域名服务器的地址向其发起请求，最终得到该域名对应的 IP 地址
5. 本地域名服务器将得到的 IP 地址返回给操作系统，同时自己将 IP 地址缓存起来
6. 操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起来
7. 至此，浏览器就得到了域名对应的 IP 地址，并将 IP 地址缓存起来

## I/O 复用技术

只使用一个进程来维护多个 socket，进程可以通过一个系统调用函数从内核中获取多个事件

select：将已连接的 socket 放入一个文件描述符集合中，调用select函数将文件描述符拷贝到内核中，让内核检查是否有网络事件发生，通过遍历的方式，当检查到有事件产生后，将此 socket 标记为可读或可写，接着再把整个文件描述符集合**拷贝**回用户态里，然后用户态还需要再通过**遍历**的方法找到可读或可写的 socket，然后再对其处理。

poll：对比 select，使用动态数组，突破了文件描述符个数的限制

epoll：使用红黑树维护待检测的文件描述符集合，时间复杂度降到$O(logn)$，epoll 使用**事件驱动**的机制，内核里**维护了一个链表来记录就绪事件**，当某个 socket 有事件发生时，通过**回调函数**内核会将其加入到这个就绪事件列表中，当用户调用 `epoll_wait()` 函数时，只会返回有事件发生的文件描述符的个数，不需要像 select/poll 那样轮询扫描整个 socket 集合，大大提高了检测的效率。

LT（水平触发）：监控到 socket 上有可读事件发生后，服务器会不断的从 epll_wait 苏醒，知道内核缓冲区数据被读完

ET（边缘触发）：只苏醒一次，即使进程没有调用 read 函数从内核读取数据，也依然只苏醒一次，因此我们程序要保证一次性将内核缓冲区的数据读取完

# 项目

## 简介

项目是为了学习 Linux 网络编程的基础知识，服务器对浏览器发送的 HTTP 请求进行解析处理，处理完成后给客户返回图片或文字资源，服务器后端使用 socket 进行网络通信，利用 I/O 多路复用来处理并发请求，事件处理模型使用模拟 Proactor 实现，还使用的是半同步/半反应堆的线程池技术来提高服务器性能。

使用了一个主线程和四个工作线程，主线程将任务添加到线程池，使用 epoll 作 I/O 多路复用的实现方式，epoll 使用 EPOLLONESHOT 保证一个 socket 在任意时刻只能被一个线程处理，同时 epoll 的触发模式选择了 ET 模式，ET 模式要高效很多，不会被同一事件触发多次，每次读都必须循环读取直到 EAGIN 错误，确保处理完。

## 事件处理模式：同步 I/O 模拟 Proactor 模式

主线程执行数据读写操作，读写操作完成后，主线程向工作线程通知这一“完成时间”，工作线程直接获得了数据读写的结果，接下来对读写的结果进行逻辑处理

## 有限状态机解析 HTTP 报文

为什么用有限状态机

①传统应用程序的控制流程基本是按顺序执行的：遵循事先设定的逻辑，从头到尾地执行。如果我们想实现不同状态对应不同的逻辑，就需要跳转代码，可能会造成逻辑混乱不清晰。每个状态都有一系列的转移，每个转移与输入和另一状态相关。当输入进来，如果它与当前状态的某个转移相匹配，机器转换为所指的状态，然后执行相应的代码。

②http引用层协议个字段都由一些特殊的字符分割，很容易可以联想到在编译原理中构造词法分析器时使用的有限状态自动机，将对于不同字段的识别过程设置为不同的状态，每当识别到分割字符时，就改变当前状态。这样将整个报文首部逐字符扫描一遍后，就可以解析出每个字段了。

主状态机和从状态机

## 半同步/半反应堆线程池

半同步/半异步模式工作流程

> - 同步线程用于处理客户逻辑
> - 异步线程用于处理I/O事件
> - 异步线程监听到客户请求后，就将其封装成请求对象并插入请求队列中
> - 请求队列将通知某个工作在**同步模式的工作线程**来读取并处理该请求对象

创建线程的开销很大，操作系统需要发生系统调用，陷入内核，调用内核API创建线程，为线程分配资源等。如果在一个I/O频繁的服务器上每次来创建线程的话，效率会很慢。

### 优点

①降低资源消耗。通过重复利用已创建的线程，降低线程创建和销毁造成的消耗。（调用内核需要发生系统调用）

②提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。

③增加线程的可管理型。线程是稀缺资源，使用线程池可以进行统一分配，调优和监控。

## 日志系统

单例模式实现日志

- 懒汉模式：即非常懒，不用的时候不去初始化，所以在第一次被使用时才进行初始化（实例的初始化放在`getinstance`函数内部）
    - 经典的线程安全懒汉模式，使用双检测锁模式（`p == NULL`检测了两次）
    - 利用局部静态变量实现线程安全懒汉模式
- **饿汉模式**：即迫不及待，在程序运行时立即初始化（实例的初始化放在`getinstance`函数外部，`getinstance`函数仅返回该唯一实例的指针）。

## 定时器

如果一个客户端与服务器长时间连接，并且不进行数据的交互，这个连接就没有存在的意义还占据了服务器的资源。在这种情况下，服务器就需要一种手段检测无意义的连接，并对这些连接进行处理。除了处理非活跃的连接之外，服务器还有一些定时事件，比如关闭文件描述符等。为实现这些功能，服务器就需要为各事件分配一个定时器。节省系统资源。

实现：升序链表

## 保证线程安全

EPOLLONESHOT