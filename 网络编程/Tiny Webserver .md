# 项目介绍

服务器对浏览器发送的 HTTP 请求进行解析处理，处理完成后给客户返回图片或文字资源，服务器后端使用 socket 进行网络通信，利用 I/O 多路复用来处理并发请求，使用线程池技术来提高服务器的性能，事件处理模型使用 Reactor 和 模拟 Proactor 实现，并发模式使用的是半同步/半反应堆模式。

使用了一个主线程和四个工作线程，主线程将任务添加到线程池，使用 epoll 作 I/O 多路复用的实现方式，epoll 使用 EPOLLONESHOT 保证一个 socket 在任意时刻只能被一个线程处理，同时 epoll 的触发模式选择了 ET 模式，ET 模式要高效很多，不会被同一事件触发多次，每次读都必须循环读取直到 EAGIN 错误，确保处理完。

## 概况

- epoll ET
- mysql（业务部分）
- 数据库连接池
- 线程池
- 日志
- 定时器
- Reactor 模式
- 读写缓冲区

## 特点

- 使用 epoll I/O复用 + 非阻塞 I/O + 边缘触发(ET) 实现高并发处理请求，事件处理模式使用的是 Reactor模式

- 线程池提高并发，降低频繁创建线程的开销

    线程池的实现模型就是半同步/半反应堆的。有三个类，任务类，任务队列类，线程池类。

- RAII 手法封装线程同步机制

- epoll 使用 EPOLLONESHOT 保证一个 socket 连接在任意时刻都只被一个线程处理

- 状态机解析 HTTP 请求，目前支持 HTTP GET、POST

- 添加定时器处理非活动连接，使用最小堆结构管理定时器

# 性能相关

## 半同步/半反应堆模式

是一种高效的并发模式（半同步/半异步模式）的实现方式，另一种并发模式是领导者/追随者模式。

- 同步线程：按照同步方式运行的线程
    - 优点：逻辑简单
    - 缺点：效率相对较低、实时性较差
- 异步线程：按照异步方式运行的线程
    - 优点：执行效率高、实时性强
    - 缺点：程序复杂、难以调试、不适合大量并发。

异步线程只有一个，由主线程充当，负责监听所有 socket 上的事件，如果有新的连接请求，主线接受得到新的连接 socket，往 epoll 内核事件中注册 socket 上的读写事件，如果连接上有读写事件，主线程将该连接 socket 插入请求队列。所有工作线程（同步线程）睡眠在请求队列上，当有任务到来，通过竞争的方式获得任务管理权。

- Reactor 模式：工作线程自己从 socket 上读取客户请求和往 socket 中写入服务器应答
- 模拟 Proactor 事件处理模式：主线程完成数据的读写，主线程将应用程序数据、任务类型等信息封装成一个任务对象，然后插入请求队列；工作线程从请求队列中取得任务对象后，直接处理即可，不需要读写操作。

## 线程池

### 为什么要使用线程池？

①降低资源消耗。通过重复利用已创建的线程，降低线程创建和销毁造成的消耗。（调用内核需要发生系统调用）

②提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。

③增加线程的可管理型。线程是稀缺资源，使用线程池可以进行统一分配，调优和监控。

### 框架

1. 服务器启动：初始化线程池
2. 端口事件请求加入任务请求队列
3. 工作线程从请求队列中拿出一个任务进行处理
4. 任务处理完毕返回线程池，返回2

主线程和工作线程之间通过一个共享的工作队列来同步，工作线程睡眠在工作队列上。当有新的任务到来时，主线程将新的任务添加到工作队列中。这将唤醒正在等待任务的工作线程，不过只有一个工作线程会获得新任务的”接管权”，他可以从工作队列中取出任务并执行。而其他的工作线程则继续睡眠在工作队列上。

### 实现

线程池有三个类：任务类、任务队列、线程池

主要组成部分：

1. 任务队列，存储需要分配的任务，用队列实现

2. 工作线程。

    工作线程不停地读取任务队列，读取里面的任务并处理。

    如果队列为空，工作线程将会被阻塞，条件变量

    队列不为空，唤醒线程，工作

3. 管理线程。

    周期性的对任务队列中的任务数量以及处于忙碌状态的工作线程个数进行检测，当任务过多就适当创建一些新线程，当任务过少就销毁一些线程。

## 数据库连接池

数据库连接是一种关键的、有限的、昂贵的资源。怎样清空不活跃的用户是需要解决的问题。数据库连接池初始化后需要创建一定量数据库连接放到连接池中。数据库连接池有最大连接数与最小连接数。不论数据库连接是否使用，连接池都将**一直保持最小连接数的连接**。连接池的达到最大数据库连接数量时，再有新的连接则会被加入到等待队列中。

### 设计思路

- 容器：对连续内存没有要求，要求头尾插入删除时间复杂度低即可。list容器即符合要求。所以通过list容器存放空闲的连接。
- 线程锁：对容器进行读取放回操作时，加锁保证安全性。
- 获取连接：
    - 有空闲连接：直接拿。
    - 无空闲连接：
        - 未达到上限：自己创建。
        - 达到上限：阻塞等待。
- 释放连接：放回容器中
- 销毁：关闭连接、释放连接池中的对象

# 单例模式

> 定义：单例模式是创建型设计模式，指的是在系统的生命周期中只能产生一个实例(对象)，确保该类的唯一性。
>
> 一般遇到的写进程池类、日志类、数据池（用来缓存数据的结构，在一处写多出读或者多处写多处读）的话都会用到单例模式。

实现：全局只有一个实例，不能通过 new 调用构造函数来创建对象，将构造函数定义为 static。静态成员函数属于整个类，在类实例化就已经分配了空间，类的非静态成员函数在类实例化后才能有内存空间。

特点：

1. 全局只有一个实例，用static特性实现，构造函数设为私有
2. 通过公有接口获得实例
3. 线程安全
4. 禁止拷贝和赋值

单例模式分为懒汉式和饿汉式，两者之间的区别在于创建实例的时间不同：懒汉式指系统运行中，实例并不存在，只有当需要使用该实例时，才会去创建并使用实例(这种方式要考虑线程安全)。饿汉式指系统一运行，就初始化创建实例，当需要时，直接调用即可。（本身就线程安全，没有多线程的问题）

