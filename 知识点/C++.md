# C++ 基础

## C++程序到可执行文件的过程

C++和c语言相似，一个C++程序从源码到执行文件，有四个过程：预编译，编译，汇编，链接

**预编译：**

1. 将所有的#define删除，并且展开所有的宏定义 
2. 处理条件预编译指令和#include指令，将被包含的文件插入到预编译指令的 
3. 过滤所有的注释 
4. 添加行号和文件名标识 

**编译：**

1. 词法分析：将源代码的字符序列分割成一系列记号 
2. 语法分析：对记号进行语法分析，产生语法树 
3. 语义分析：判断表达式是够有意义 
4. 代码优化 
5. 目标代码生成：生成汇编代码 
6. 目标代码优化 

**汇编：**

将汇编代码转变为机器可以执行的指令

**链接：**

将不同的源文件产生的目标文件进行链接，从而实现一个可以执行的程序

链接可以分为动态链接和静态链接：

## 动态链接和静态链接有什么区别

静态链接：

在链接的时候就已经把要调用的函数或者过程链接到了生成的可执行文件中，就算你去把静态库删除也不会影响可执行文件的执行。生成的静态链接库，Windows下以.lib为后缀，Linux下以.a为后缀。

动态链接：

在链接到时候没有把调用的函数链接进去，而是在执行过程中，再去找要链接的函数，生成的可执行文件中没有函数代码，只包含函数的重定位信息，所以当你删除动态库时，可执行文件就不能运行。生成的动态链接库，Windows下以.dll为后缀，Linux下以.so为后缀。

静态链接占用内存大，但是运行速度较快，效率高

动态链接占用内存较小，但是运行速度没有静态链接块。

## C++ 三大特性

> **封装**
>
> 把客观事物抽象为类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏，C++ 中将公共的数据或方法使用 public 修饰，而不希望被访问的数据或方法采用 private 修饰。
>
> **继承**
>
> 类的派生指的是从已有类产生新类的过程。原有的类成为基类或父类，产生的新类称为派生类或子类，子类继承基类后，可以创建子类对象来调用基类的函数，变量等。
>
> 继承有三种方式：
>
> **多态**
>
> 使用同一个接口但效果不同（重载实现编译时多态，虚函数实现运行时多态）
>
> 多态有两种形式的多态，一种是静态多态，一种是动态多态。
>
> 静态多态。静态多态的设计思想：对于相关的对象类型，直接实现它们各自的定义，不需要共有基类，甚至可以没有任何关系。只需要各个具体类的实现中要求相同的接口声明，静态多态本质上就是模板的具现化。
>
> 动态多态。对于相关的对象类型，确定它们之间的一个共同功能集，然后在基类中，把这些共同的功能声明为多个公共的虚函数接口。各个子类重写这些虚函数，以完成具体的功能。具体实现就是 C++ 的虚函数。
>
> 如何实现多态：
>
> 1. 重载。函数重载和运算符重载，编译期。
>
> 2. 虚函数。子类的多态性，运行期。
>
>     在继承关系中，对于父类的方法我们也同样使用。但是正常来说，我们希望方法的行为取决于调用方法的对象，而不是指针或引用指向的对象有关。
>
> 3. 模板，类模板，函数模板。编译期

## 虚函数

> 当⼀个类中包含虚函数时，编译器会为该类⽣成⼀个虚函数表，保存该类中虚函数的地址，同样，派⽣类继承基类，派⽣类中⾃然⼀定有虚函数，所以编译器也会为派⽣类⽣成⾃⼰的虚函数表。当我们定义⼀个派⽣类对象时，编译器检测该类型有虚函数，所以为这个派⽣类对象⽣成⼀个虚函数指针，指向该类型的虚函数表，这个虚函数指针的初始化是在构造函数中完成的。
>
> 如果有⼀个基类类型的指针，指向派⽣类，那么当调⽤虚函数时，就会根据所指真正对象的虚函数表指针去寻找虚函数的地址，也就可以调⽤派⽣类的虚函数表中的虚函数以此实现多态。

**虚析构函数**

> 如果类是父类，则必须声明为虚析构函数。基类声明一个虚析构函数，为了确保释放派生对象时，按照正确的顺序调用析构函数。

**虚函数表原理**

> C++实现虚函数的方法是：为每个类对象添加一个隐藏成员，隐藏成员保存了一个指针，这个指针叫**虚表指针**（vptr），它指向一个**虚函数表**（virtual function table, vtbl）
>
> **虚函数表**就像一个数组，表中有许多的**槽（slot）**，每个槽中存放的是一个虚函数的地址（可以理解为数组里存放着指向每个虚函数的指针）
>
> 即：**每个类使用一个虚函数表，每个类对象用一个虚表指针**
>
> 在有虚函数的类的实例对象中，这个表被分配在了这个实例对象的内存中（就和上面说的一样），当我们用父类的指针来操作一个子类的时候，这张表就像一个地图一样，指明了实际所应该调用的函数

## 指针和引用的区别

> - 指针是一个变量，存储的是一个地址，引用跟原来的变量实质上是同一个东西，是原变量的别名；
> - 指针可以为空，引用不能为 NULL 且在定义时必须初始化；
> - 指针在初始化后可以改变指向，而引用在初始化之后不可再改变；
> - sizeof 指针得到的是本指针的大小，sizeo f引用得到的是引用所指向变量的大小；
> - 当把指针作为参数进行传递时，也是将实参的一个拷贝传递给形参，两者指向的地址相同，但不是同一个变量，在函数中改变这个变量的指向不影响实参，而引用却可以。
> - 在 C++ 中，指针和引用经常用于函数的参数传递，然而，指针传递参数和引用传递参数是有本质上的不同的：**指针传递**参数本质上是**值传递**的方式，它所传递的是一个地址值。值传递的特点是被调函数对形式参数的任何操作都是作为局部变量进行，不会影响主调函数的实参变量的值。而在**引用传递**过程中， 被调函数的形参虽然也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址（指针放的是实参变量地址的副本）。

## const 关键字

> 1. const 修饰变量：限定变量为不可修改。
>
> 2. const 修饰指针：指针常量和指向常量的指针
>
> 3. const 和函数：有以下几种形式
>
>     `const int& fun(int& a); //修饰返回值
>     int& fun(const int& a); //修饰形参
>     int& fun(int& a) const{} //const成员函数`
>
> 4. const 和类：
>
>     - const 修饰成员变量：在某个对象的声明周期内是常量，但是对于整个类而言是可以改变的。因为类可以创建多个对象，不同的对象其 const 成员变量的值是不同的。切记，不能再类内初始化 const 成员变量，因为类的对象没创建前，编译器并不知道 const 成员变量是什么，因此 const 数据成员只能在初始化列表中初始化。
>     - const 修饰成员函数：主要目的是防止成员函数修改成员变量的值，即该成员函数并不能修改成员变量。
>     - const 对象：常对象，常对象只能调用常函数。
>
> 5. 限定成员函数不可以修改任何数据成员

## static 关键字

> static 修饰的普通变量初始化在 main 函数执行前
>
> 修饰变量：
>
> - 局部变量
>
>     - 局部变量被定义为局部静态变量；
>     - 内存中的位置：静态存储区；
>     - 初始化：局部的静态变量只能被初始化一次；
>     - 作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域随之结束。
>
>     static 修饰局部变量时，改变了局部变量存储的位置和生命周期（离开作用域后没有被销毁，但不能访问，直到程序结束），但作用域不改变 。
>
> - 全局变量
>
>     - 在全局变量之前加上关键字static，全局变量就被定义成为一个全局静态变量。
>     - 内存中的位置：静态存储区；
>     - 初始化：未经初始化的全局静态变量会自动初始化为0；
>     - 作用域：本文件中。
>
>     区别全局变量和静态全局变量：
>
>     > 全局变量本身就是静态存储方式， 静态全局变量当然也是静态存储方式。两者的区别在于非静态全局变量的作用域是整个源程序， 当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的（在其他源文件中使用时加上 extern 关键字重新声明即可）。 而**静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效， 在同一源程序的其它源文件中不能使用它**。
>
> 修饰函数：
>
> 修饰普通函数，表明函数的作用范围，仅在定义该函数的文件内才能使用。（和全局变量一样限制了作用域）
>
> 修饰类：
>
> - 成员变量
>
>     用 static 修饰类的数据成员实际使其成为类的全局变量，会被类的所有对象共享，**包括派生类的对象**。
>
>     因此，static 成员必须在类外进行初始化，而不能在构造函数内进行初始化。不过也可以用 const 修饰 static 数据成员在类内初始化 。
>
> - 成员函数
>
>     用static修饰成员函数，使这个类只存在这一份函数，所有对象共享该函数，不含 this 指针。
>
>     静态成员是可以独立访问的，也就是说，无须创建任何对象实例就可以访问。
>
>     **不可以同时用 const 和 static 修饰成员函数。**

## C++内存空间分配

> - 栈：由编译器管理分配和回收，存放局部变量和函数参数；
> - 堆：由程序员管理，需要手动进行分配和回收，可能会出现内存泄漏和空闲碎片的情况；
> - 全局/静态存储区：分为初始化和未初始化两个相邻区域，存储初始化和未初始化的全局变量和静态变量；
> - 常量存储区：存储常量，一般不能修改；
> - 代码区：存放程序的二进制代码。

## 堆和栈区别，哪个分配快

> - 申请方式不同：
>     - 堆是由程序员管理，需要手动进行分配和回收
>     - 栈由编译器自动分配空间
> - 申请大小限制：
>     - 堆向高地址扩展，是不连续的内存区域，大小可以灵活调整
>     - 栈是高地址向低地址扩展，栈底高地址，空间小
> - 内存管理机制：
>     - 堆：系统有一个记录空闲内存地址的链表，当系统收到程序申请时，遍历该链表，寻找第一个空间大于申请空间的堆结点，删除空闲结点链表中的该结点，并将该结点空间分配给程序（大多数系统会在这块内存空间首地址记录本次分配的大小，这样 delete 才能正确释放本内存空间，另外系统会将多余的部分重新放入空闲链表中）
>     - 栈：只要栈的剩余空间大于所申请空间，系统为程序提供内存，否则报异常提示栈溢出。
> - 申请效率：
>     - 堆由程序员分配，速度慢，有碎片
>     - 栈由系统分配，速度快，不会有碎片

## new / delete 与 malloc / free 

**区别：**

> - 前者是 C++ 运算符，后者是 C/C++ 语言标准库函数
> - new 自动计算要分配的空间大小，malloc 需要手工计算
> - new 是类型安全的，malloc 不是
> - new 调用名为 **operator new** 的标准库函数分配足够空间并调用相关对象的构造函数，delete 对指针所指对象运行适当的析构函数；然后通过调用名为 **operator delete** 的标准库函数释放该对象所用内存。后者均没有相关调用
> - 后者需要库文件支持，前者不用
> - new 是封装了 malloc，直接 free 不会报错，但是这只是释放内存，而不会析构对象

**调用 new 操作符分配对象**

> 1. 调用operator new函数分配一块足够大的，原始的空间；
> 2. 编译器运行相应的构造函数以构造对象，并传入初值；
> 3. 构造完对象后，就返回一个指向该对象的指针。

**为什么要 new / delete**

> 在对非基本数据类型的对象使用的时候，对象创建的时候还需要执行构造函数，销毁的时候要执行析构函数。而 malloc/free 是库函数，是已经编译的代码，所以不能把构造函数和析构函数的功能强加给 malloc/free ，所以 new/delete 是必不可少的。

## `final` 和 `override`

> 当在父类中使用了虚函数时候，你可能需要在某个子类中对这个虚函数进行重写，以下方法都可以：
>
> ```cpp
> class A {
>     virtual void foo();
> }
> class B : public A {
>     void foo(); //OK
>     virtual void foo(); // OK
>     void foo() override; //OK
> }
> ```
>
> 使用 `override`关键字指定了子类的这个虚函数是重写的父类的，如果你名字不小心打错了的话，编译器是不会编译通过的。
>
> **final**
>
> 当不希望某个类被继承，或不希望某个虚函数被重写，可以在类名和虚函数后添加 final 关键字，添加 final 关键字后被继承或重写，编译器会报错。

## C++ 构造函数

> 类对象被创建时，编译器为对象分配内存空间，并自动调用构造函数，由构造函数完成成员的初始化工作。
>
> 因此构造函数的的作用是初始化对象的成员函数。
>
> - **默认构造函数：**如果没有人为构造函数，则编译器会自动默认生成一个无参构造函数。
> - **一般构造函数：**包含各种参数，一个类可以有多个一般构造函数，前提是参数的个数和类型和传入参数的顺序都不相同，根据传入参数调用对应的构造函数。
> - **拷贝构造函数：**拷⻉构造函数的函数参数为对象本身的引用，用于根据⼀个已存在的对象复制出⼀个新的该类的对象，⼀般在函数中会将已存在的对象的数据成员的值⼀⼀复制到新创建的对象中。如果没有显示的写拷⻉构造函数，则系统会默认创建⼀个拷⻉构造函数，但当类中有指针成员时，最好不要使⽤编译器提供的默认的拷⻉构造函 数，最好⾃⼰定义并且在函数中执⾏深拷⻉。
> - **移动构造函数：**有时候我们会遇到这样一种情况，我们用对象 a 初始化对象 b 后对象 a 我们就不在使用了，但是对象 a 的空间还在呀（在析构之前），既然拷贝构造函数，实际上就是把 a 对象的内容复制一份到 b 中，那么为什么我们不能直接使用 a 的空间呢？这样就避免了新的空间的分配，大大降低了构造的成本。这就是移动构造函数设计的初衷。拷贝构造函数中，对于指针，我们一定要采用深层复制，而移动构造函数中，对于指针，我们采用浅层复制。
>
> > 但是指针的浅层复制是非常危险的。浅层复制之所以危险，是因为两个指针共同指向一片内存空间，若第一个指针将其释放，另一个指针的指向就不合法了（pointer dangling）。所以我们只要避免第一个指针释放空间就可以了。避免的方法就是将第一个指针（比如a->value）置为NULL，这样在调用析构函数的时候，由于有判断是否为NULL的语句，所以析构a的时候并不会回收a->value指向的空间（同时也是b->value指向的空间）
>
> - **赋值构造函数：**=运算符的重载，类似拷贝构造函数，将 = 右边的类对象赋值给类对象左边的对象，不属于构造函数，=两边的对象必须都要被创建。
>
> - **类型转换构造函数：**有时候不想要隐式转换，用explict关键字修饰。

## 左值和右值

> 左值：**可以取地址、位于赋值符号左边**的值，左值是表达式结束（不一定是赋值表达式）后依然存在的对象。
>
> 右值：可以提供数据值的表达式（不一定可以寻址，例如存储于寄存器中的数据）。如：
>
> 1. 字面值(字符串字面值除外)，例如1，'a', true等
> 2. 返回值为非引用的函数调用或操作符重载，例如：str.substr(1, 2), str1 + str2, or it++
> 3. 后置自增和自减表达式(a++, a--)
> 4. 算术表达式（x + y;）
> 5. 逻辑表达式
> 6. 比较表达式
> 7. 取地址表达式
> 8. lambda表达式`auto f = []{return 5;};`
>
> 右值又有纯右值和将亡值的说法。非引用返回的临时变量、运算表达式产生的临时变量、原始字面量和 lambda 表达式等都是纯右值。而将亡值是与右值引用相关的表达式，比如，将要被移动的对象、T&& 函数返回值、std::move 返回值和转换为 T&& 的类型的转换函数的返回值等。

## 左值引用和右值引用

> 右值引用是 C++11 中新增加的一个很重要的特性，他主是要用来解决 C++98/03 中遇到的两个问题
>
> - 第一个问题就是临时对象非必要的昂贵的拷贝操作
> - 第二个问题是在模板函数中如何按照参数的实际类型进行转发。
>
> 要拿到一个将亡值，就需要用到右值引用：`T &&`。右值引用的声明让这个临时值的生命周期得以延长、只要变量还活着，那么将亡值将继续存活。C++11 提供了 `std::move` 这个方法将左值参数无条件的转换为右值，有了它我们就能够方便的获得一个右值临时对象。

**移动语义**

> 右值引用的一个重要作用是用来支持移动语义的。那我们知道了移动语义是通过右值来匹配临时值的，那么很自然会想到，普通的左值是否也能借助移动语义来优化性能呢？C++11为了解决这个问题，提供了 std::move 方法来将左值转换为右值，从而方便应用移动语义。move是将对象资源的所有权从一个对象转移到另一个对象，只是转移，没有内存的拷贝，这就是所谓的 move 语义。
>
> move 实际上它并不能移动任何东西，它唯一的功能是将一个左值强制转换为一个右值引用。如果是一些基本类型比如 int 和 char[10] 定长数组等类型，使用 move 的话仍然会发生拷贝（因为没有对应的移动构造函数）。所以，move 对于含资源（堆内存或句柄）的对象来说更有意义。

**完美转发**

> 在函数模板中，完全依照模板的参数的类型（即保持参数的左值、右值特征），将参数传递给函数模板中调用的另外一个函数。C++11 中的 std::forward 正是做这个事情的，他会按照参数的实际类型进行转发。

## C++ 类型转换

> 1. **static_cast**：用于基本数据类型之间的转换，如：void*和其他类型指针之间的转换、子类对象的指针转换成父类对象指针。
>
>     最好把所有**隐式转换**都用 static_cast 代替
>
> 2. **const_cast**：用来移除变量的 const 特性，但是不能用于去除变量的常量性，而是去除指向对象的引用或指针的常量性，因此去除对象必须是指针或者引用。
>
>     - 指向常量的指针被转化成非常量指针，并且仍然指向原来的对象；
>
>     - 常量引用被转换成非常量引用，并且仍然指向原来的对象；
>
>     - 常量对象被转换成非常量对象。
>
> 3. **dynamic_cast**：不能用于内置类型转换，主要是继承关系的子类和父类之间的转换，一般是downcasting，向下强制转换。
>
>     子类指针指向父类指针，作用和 static_cast 一样，但将父类指针转化成子类指针，static_cast 可能会失败
>
>     **转换成功会返回引用或者指针，失败返回null**
>
> 4. **reinterpret_cast**：将任意类型指针转换为其他类型的指针。
>
>     改变指针或者引用的类型
>
>     - 将指针或者引用转换成一个足够长度的整型
>
>     - 将整型转换成指针或引用类型

## lambda 表达式

> **lambda 表达式特点**
>
> lambda 表达式定义了一个匿名函数，并且可以捕获一定范围内的变量。lambda 表达式的语法形式简单归纳如下：
>
> ```cpp
> [capture](params) opt -> ret {body;};
> ```
>
> 其中 `capture` 是捕获列表，`params` 是参数列表，`opt` 是函数选项，`ret` 是返回值类型，`body` 是函数体。
>
> 

## 智能指针

**为什么要使用智能指针？**

> 1. 防止内存泄漏：C++ 在堆上申请内存后，需要手动对内存进行释放。
> 2. 多线程下对象析构问题，造成这个问题本质的原因是类对象自己销毁(析构)的时候无法对自己加锁，所以要独立出来，采用这个中间层。

**shared_ptr**

> 共享所有权，也就是说多个指针可以指向一个相同的对象，当最后一个shared_ptr离开作用域的时候才会释放掉内存。
>
> **实现原理：**
> 在 shared_ptr 内部有一个共享引用计数器来自动管理，计数器实际上就是指向该资源指针的个数，每当复制一个 shared_ptr，引用计数会 + 1。当一个 shared_ptr 离开作用域时，引用计数会 - 1，当引用计数为 0 的时候，则 delete 内存。当计数器为0的时候指针才会彻底释放掉这个资源。
>
> **线程安全问题：**
>
> shared_ptr 可能的线程安全隐患大概有如下几种，一是引用计数的加减操作是否线程安全，二是shared_ptr修改指向时，是否线程安全。
>
> 1. shared_ptr 的引用计数是原子操作的，所以引用计数的加减是线程安全的。
> 2. shared_ptr修改指针指向的时候会不安全。 同一个shared_ptr被多个线程“读”是安全的。同一个shared_ptr被多个线程“写”是不安全的(多个线程操作同一个shared_ptr对象)。

**weak_ptr**

> 它主要是为了配合 `shared_ptr` 而存在的。就像它的名字一样，它本身是一个弱指针，因为它本身是不能直接调用原生指针的方法的。如果想要使用原生指针的方法，需要将其先转换为一个 `shared_ptr`。
>
> 主要为了解决 `shared_ptr` 指针循环引用（a 对象持有 b 对象，b 对象持有 a 对象）造成的内存泄露问题，`weak_ptr` 不会增加引用计数，通过将循环引用中的一方修改为弱引用，可以避免内存泄漏。
>
> **方法**
>
> 1. expired() 判断所指向的原生指针是否被释放，如果被释放了返回 true，否则返回 false
> 2. use_count() 返回原生指针的引用计数
> 3. lock() 返回 shared_ptr，如果原生指针没有被释放，则返回一个非空的 shared_ptr，否则返回一个空的 shared_ptr
> 4. reset() 将本身置空

**unique_ptr**

> `unique_ptr `的核心特点就如它的名字一样，它拥有对持有对象的唯一所有权。即两个 `unique_ptr` 不能同时指向同一个对象，体现在：
>
> 1. `unique_ptr` 不能被复制到另外一个 `unique_ptr`
> 2. `unique_ptr` 所持有的对象只能通过转移语义将所有权转移到另外一个 `unique_ptr`

## 原子操作

> 它表示在多个线程访问同一个全局资源的时候，能够确保所有其他的线程都不在同一时间内访问相同的资源。也就是他确保了在同一时刻只有唯一的线程对这个资源进行访问。这有点类似互斥对象对共享资源的访问的保护，但是原子操作更加接近底层，因而效率更高。
>
> 互斥对象的使用，保证了同一时刻只有唯一的一个线程对这个共享进行访问，从执行的结果来看，互斥对象保证了结果的正确性，但是也有非常大的性能损失。

# STL

**STL包含6大部件：容器、迭代器、算法、仿函数、适配器和空间配置器。**

- 容器：容纳一组元素的对象，提供各种数据结构。
- 迭代器：提供一种访问容器中每个元素的方法，从实现的角度来说，迭代器是一种将`operator*`, `operator->`, `operator++`等指针操作赋予 重载的类模板。
- 仿函数：一个行为类似函数的对象，调用它就像调用函数一样，重载了`operator()`的类或者类模板。
- 算法：包括查找算法、排序算法等等。
- 适配器：用来修饰容器等，比如queue和stack，底层借助了deque。
- 空间配置器：负责空间配置和管理，是一个实现了动态空间配置，空间管理，空间释放的类模板。

## 空间配置器

**为什么需要空间配置器**

> 我们知道动态开辟内存时，要在堆上申请，但若是我们需要频繁的在堆开辟释放内存，则就会**在堆上造成很多外部碎片**，浪费了内存空间；每次都要进行调用 **malloc、free** 函数等操作，使空间就会增加一些附加信息，降低了空间利用率；随着外部碎片增多，内存分配器在找不到合适内存情况下需要合并空闲块，浪费了时间，大大降低了效率。于是就设置了二级空间配置器，**当开辟内存<=128bytes时，即视为开辟小块内存，则调用二级空间配置器。**

**二级空间配置器**

> 1. 维护16条链表，分别是 0-15 号链表，最小 8 字节，以 8 字节逐渐递增，最大 128 字节，你传入一个字节参数，表示你需要多大的内存，会自动帮你校对到第几号链表（如需要13bytes空间，我们会给它分配16bytes大小），在找到第 n 个链表后查看链表是否为空，如果不为空直接从对应的 free_list 中拔出，将已经拨出的指针向后移动一位。
>
> 2. 对应的 free_list 为空，先看其内存池是不是空时，如果内存池不为空:
>
>     （1）先检验它剩余空间是否够20个节点大小（即所需内存大小(提升后) * 20），若足够则直接从内存池中拿出20个节点大小空间，将其中一个分配给用户使用，另外19个当作自由链表中的区块挂在相应的 free_list 下，这样下次再有相同大小的内存需求时，可直接拨出。
>
>     （2）如果不够20个节点大小，则看它是否能满足1个节点大小，如果够的话则直接拿出一个分配给用户，然后从剩余的空间中分配尽可能多的节点挂在相应的 free_list 中。
>
>     （3）如果连一个节点内存都不能满足的话，则将内存池中剩余的空间挂在相应的 free_list 中（找到相应的 free_list），然后再给内存池申请内存。
>
> 3. 内存池为空，申请内存此时二级空间配置器会使用 malloc() 从 heap 上申请内存，（一次所申请的内存大小为2 * 所需节点内存大小（提升后）* 20 + 一段额外空间），申请40块，一半拿来用，一半放内存池中。
>
> 4. malloc 没有成功 在第三种情况下，如果 malloc() 失败了，说明 heap 上没有足够空间分配给我们了，这时，二级空间配置器会从比所需节点空间大的 free_list 中一一搜索，从比它所需节点空间大的 free_list 中拔除一个节点来使用。如果这也没找到，说明比其大的 free_list 中都没有自由区块了，那就要调用一级适配器了。
>
> 释放时调用 deallocate() 函数，若释放的 n>128，则调用一级空间配置器，否则就直接将内存块挂上自由链表的合适位置。

## vector

> vector 是动态空间，随着元素的加入它内部机制会自行空充空间以容纳新元素。vector 维护了一个连续的线性空间，普通指针就可以满足要求作为 vector 的迭代器，随机访问迭代器。vector 里面其实有三个迭代器，分别是指向空间头部的 iterator，指向空间尾部的 iterator 和指向可用空间的 iterator。当有新的元素插入时，如果当前容量够就直接插入，如果容量不够则扩容至两倍或1.5倍，如果两倍不足，则扩容至足够大的空间。由于扩充过程不是在原有的空间后面追加，而是重新申请一块新的连续内存，所以所有迭代器都会失效。

### reverse 和 resize 的区别

> vector 的 reserve 增加了 vector 的 capacity，但是它的 size 没有改变
>
> resize 改变了 vector 的 capacity 同时也增加了它的 size，原因如下：
>
> 1. reserve 是容器预留空间，但在空间内不真正创建元素对象，所以在没有添加新的对象之前，不能引用容器内的元素。加入新的元素时，要调用 push_back()/insert() 函数。
> 2. resize 是改变容器的大小，且在创建对象，因此，调用这个函数之后，就可以引用容器内的对象了，因此当加入新的元素时，用 operator[] 操作符，或者用迭代器来引用元素对象。此时再**调用 push_back() 函数，是加在这个新的空间后面的。**

### 迭代器失效

> 当插入一个元素到 vector 中，由于引起了内存重新分配，所有指向原内存的迭代器全部失效。
>
> 当删除容器中一个元素后，该迭代器所指向的元素已经被删除，那么也造成迭代器失效。erase 方法会返回下一个有效的迭代器，所以当我们要删除某个元素时，需要 it=vec.erase(it)

### vector 支持越界检查吗

> 通过 operator[] 获取数组元素，不会检查下标有效性，需要检查的时候使用 at 接口

### push_back 和 emplace_back 区别

> **使用 push_back() 函数需要调用拷贝构造函数和转移构造函数，而使用 emplace_back() 插入的元素原地构造，不需要触发拷贝构造和转移构造**，效率更高。

### 如何释放空间

> vector 的内存占用空间只增不减，比如你首先分配了10,000个字节，然后 erase 掉后面9,999个，留下一个有效元素，但是内存占用仍为10,000个。
>
> **所有的内存空间是在 vector 析构时候才能被系统回收。**
>
> empty() 用来检测容器是否为空的，clear() 可以清空所有元素。但是即使 clear()，vector 所占用的内存空间依然如故，无法保证内存的回收。vector，可以用 swap() 来帮助你释放内存。
>
> ```cpp
> vector().swap(Vec); //清空Vec的内存；
> ```

## deque

> vector 是单向开口的连续线性空间，deque 是一种双向开口的连续线性空间。双向开口就是说 deque 支持从头尾两端进行元素的插入和删除操作。deque没有容量的概念，因为它是动态以分段连续空间组合而成，随时可以增加一段新的空间并连接起来。由于要维护这种整体连续的假象，并提供随机存取的接口。

## map 和 unordered_map

> map 底层数据结构：红黑树，有序，不重复
>
> unordered_map 底层数据结构：hash table，无序
>
> **map 缺点**
>
> - 占用的空间大：红黑树的每一个节点需要保存其父节点位置、孩子节点位置及红/黑性质，因此每一个节点占用空间大。
> - 查询平均时间不如unordered_map。
>
> **unordered_map 使用什么方法解决 hash 冲突**
>
> 拉链法