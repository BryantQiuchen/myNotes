# C++ 基础

## C++ 三大特性

> **封装**
>
> 把客观事物抽象为类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏，C++ 中将公共的数据或方法使用 public 修饰，而不希望被访问的数据或方法采用 private 修饰。
>
> **继承**
>
> 类的派生指的是从已有类产生新类的过程。原有的类成为基类或父类，产生的新类称为派生类或子类，子类继承基类后，可以创建子类对象来调用基类的函数，变量等。
>
> 继承有三种方式：
>
> **多态**
>
> 使用同一个接口但效果不同（重载实现编译时多态，虚函数实现运行时多态）
>
> 多态有两种形式的多态，一种是静态多态，一种是动态多态。
>
> 静态多态。静态多态的设计思想：对于相关的对象类型，直接实现它们各自的定义，不需要共有基类，甚至可以没有任何关系。只需要各个具体类的实现中要求相同的接口声明，静态多态本质上就是模板的具现化。
>
> 动态多态。对于相关的对象类型，确定它们之间的一个共同功能集，然后在基类中，把这些共同的功能声明为多个公共的虚函数接口。各个子类重写这些虚函数，以完成具体的功能。具体实现就是 C++ 的虚函数。
>
> 如何实现多态：
>
> 1. 重载。函数重载和运算符重载，编译期。
>
> 2. 虚函数。子类的多态性，运行期。
>
>     在继承关系中，对于父类的方法我们也同样使用。但是正常来说，我们希望方法的行为取决于调用方法的对象，而不是指针或引用指向的对象有关。
>
> 3. 模板，类模板，函数模板。编译期

## 虚函数

> 当⼀个类中包含虚函数时，编译器会为该类⽣成⼀个虚函数表，保存该类中虚函数的地址，同样，派⽣类继承基类，派⽣类中⾃然⼀定有虚函数，所以编译器也会为派⽣类⽣成⾃⼰的虚函数表。当我们定义⼀个派⽣类对象时，编译器检测该类型有虚函数，所以为这个派⽣类对象⽣成⼀个虚函数指针，指向该类型的虚函数表，这个虚函数指针的初始化是在构造函数中完成的。
>
> 如果有⼀个基类类型的指针，指向派⽣类，那么当调⽤虚函数时，就会根据所指真正对象的虚函数表指针去寻找虚函数的地址，也就可以调⽤派⽣类的虚函数表中的虚函数以此实现多态。

**虚析构函数**

> 如果类是父类，则必须声明为虚析构函数。基类声明一个虚析构函数，为了确保释放派生对象时，按照正确的顺序调用析构函数。

## 指针和引用的区别

> - 指针是一个变量，存储的是一个地址，引用跟原来的变量实质上是同一个东西，是原变量的别名；
> - 指针可以为空，引用不能为 NULL 且在定义时必须初始化；
> - 指针在初始化后可以改变指向，而引用在初始化之后不可再改变；
> - sizeof 指针得到的是本指针的大小，sizeo f引用得到的是引用所指向变量的大小；
> - 当把指针作为参数进行传递时，也是将实参的一个拷贝传递给形参，两者指向的地址相同，但不是同一个变量，在函数中改变这个变量的指向不影响实参，而引用却可以。
> - 在 C++ 中，指针和引用经常用于函数的参数传递，然而，指针传递参数和引用传递参数是有本质上的不同的：**指针传递**参数本质上是**值传递**的方式，它所传递的是一个地址值。值传递的特点是被调函数对形式参数的任何操作都是作为局部变量进行，不会影响主调函数的实参变量的值。而在**引用传递**过程中， 被调函数的形参虽然也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址（指针放的是实参变量地址的副本）。

## const 关键字

> 1. const 修饰变量：限定变量为不可修改。
>
> 2. const 修饰指针：指针常量和指向常量的指针
>
> 3. const 和函数：有以下几种形式
>
>     `const int& fun(int& a); //修饰返回值
>     int& fun(const int& a); //修饰形参
>     int& fun(int& a) const{} //const成员函数`
>
> 4. const 和类：
>
>     - const 修饰成员变量：在某个对象的声明周期内是常量，但是对于整个类而言是可以改变的。因为类可以创建多个对象，不同的对象其 const 成员变量的值是不同的。切记，不能再类内初始化 const 成员变量，因为类的对象没创建前，编译器并不知道 const 成员变量是什么，因此 const 数据成员只能在初始化列表中初始化。
>     - const 修饰成员函数：主要目的是防止成员函数修改成员变量的值，即该成员函数并不能修改成员变量。
>     - const 对象：常对象，常对象只能调用常函数。
>
> 5. 限定成员函数不可以修改任何数据成员

## static 关键字

> static 修饰的普通变量初始化在 main 函数执行前
>
> 修饰变量：
>
> - 局部变量
>
>     - 局部变量被定义为局部静态变量；
>     - 内存中的位置：静态存储区；
>     - 初始化：局部的静态变量只能被初始化一次；
>     - 作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域随之结束。
>
>     static 修饰局部变量时，改变了局部变量存储的位置和生命周期（离开作用域后没有被销毁，但不能访问，直到程序结束），但作用域不改变 。
>
> - 全局变量
>
>     - 在全局变量之前加上关键字static，全局变量就被定义成为一个全局静态变量。
>     - 内存中的位置：静态存储区；
>     - 初始化：未经初始化的全局静态变量会自动初始化为0；
>     - 作用域：本文件中。
>
>     区别全局变量和静态全局变量：
>
>     > 全局变量本身就是静态存储方式， 静态全局变量当然也是静态存储方式。两者的区别在于非静态全局变量的作用域是整个源程序， 当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的（在其他源文件中使用时加上 extern 关键字重新声明即可）。 而**静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效， 在同一源程序的其它源文件中不能使用它**。
>
> 修饰函数：
>
> 修饰普通函数，表明函数的作用范围，仅在定义该函数的文件内才能使用。（和全局变量一样限制了作用域）
>
> 修饰类：
>
> - 成员变量
>
>     用 static 修饰类的数据成员实际使其成为类的全局变量，会被类的所有对象共享，**包括派生类的对象**。
>
>     因此，static 成员必须在类外进行初始化，而不能在构造函数内进行初始化。不过也可以用 const 修饰 static 数据成员在类内初始化 。
>
> - 成员函数
>
>     用static修饰成员函数，使这个类只存在这一份函数，所有对象共享该函数，不含 this 指针。
>
>     静态成员是可以独立访问的，也就是说，无须创建任何对象实例就可以访问。
>
>     **不可以同时用 const 和 static 修饰成员函数。**

## C++内存空间分配

> - 栈：由编译器管理分配和回收，存放局部变量和函数参数；
> - 堆：由程序员管理，需要手动进行分配和回收，可能会出现内存泄漏和空闲碎片的情况；
> - 全局/静态存储区：分为初始化和未初始化两个相邻区域，存储初始化和未初始化的全局变量和静态变量；
> - 常量存储区：存储常量，一般不能修改；
> - 代码区：存放程序的二进制代码。

## 堆和栈区别，哪个分配快

> - 申请方式不同：
>     - 堆是由程序员管理，需要手动进行分配和回收
>     - 栈由编译器自动分配空间
> - 申请大小限制：
>     - 堆向高地址扩展，是不连续的内存区域，大小可以灵活调整
>     - 栈是高地址向低地址扩展，栈底高地址，空间小
> - 内存管理机制：
>     - 堆：系统有一个记录空闲内存地址的链表，当系统收到程序申请时，遍历该链表，寻找第一个空间大于申请空间的堆结点，删除空闲结点链表中的该结点，并将该结点空间分配给程序（大多数系统会在这块内存空间首地址记录本次分配的大小，这样 delete 才能正确释放本内存空间，另外系统会将多余的部分重新放入空闲链表中）
>     - 栈：只要栈的剩余空间大于所申请空间，系统为程序提供内存，否则报异常提示栈溢出。
> - 申请效率：
>     - 堆由程序员分配，速度慢，有碎片
>     - 栈由系统分配，速度快，不会有碎片

## new / delete 与 malloc / free 

**区别：**

> - 前者是 C++ 运算符，后者是 C/C++ 语言标准库函数
> - new 自动计算要分配的空间大小，malloc 需要手工计算
> - new 是类型安全的，malloc 不是
> - new 调用名为 **operator new** 的标准库函数分配足够空间并调用相关对象的构造函数，delete 对指针所指对象运行适当的析构函数；然后通过调用名为 **operator delete** 的标准库函数释放该对象所用内存。后者均没有相关调用
> - 后者需要库文件支持，前者不用
> - new 是封装了 malloc，直接 free 不会报错，但是这只是释放内存，而不会析构对象

**调用 new 操作符分配对象**

> 1. 调用operator new函数分配一块足够大的，原始的空间；
> 2. 编译器运行相应的构造函数以构造对象，并传入初值；
> 3. 构造完对象后，就返回一个指向该对象的指针。

**为什么要 new / delete**

> 在对非基本数据类型的对象使用的时候，对象创建的时候还需要执行构造函数，销毁的时候要执行析构函数。而 malloc/free 是库函数，是已经编译的代码，所以不能把构造函数和析构函数的功能强加给 malloc/free ，所以 new/delete 是必不可少的。

## `final` 和 `override`

> 当在父类中使用了虚函数时候，你可能需要在某个子类中对这个虚函数进行重写，以下方法都可以：
>
> ```cpp
> class A {
>     virtual void foo();
> }
> class B : public A {
>     void foo(); //OK
>     virtual void foo(); // OK
>     void foo() override; //OK
> }
> ```
>
> 使用 `override`关键字指定了子类的这个虚函数是重写的父类的，如果你名字不小心打错了的话，编译器是不会编译通过的。
>
> **final**
>
> 当不希望某个类被继承，或不希望某个虚函数被重写，可以在类名和虚函数后添加 final 关键字，添加 final 关键字后被继承或重写，编译器会报错。

## C++ 构造函数

> 类对象被创建时，编译器为对象分配内存空间，并自动调用构造函数，由构造函数完成成员的初始化工作。
>
> 因此构造函数的的作用是初始化对象的成员函数。
>
> - **默认构造函数：**如果没有人为构造函数，则编译器会自动默认生成一个无参构造函数。
> - **一般构造函数：**包含各种参数，一个类可以有多个一般构造函数，前提是参数的个数和类型和传入参数的顺序都不相同，根据传入参数调用对应的构造函数。
> - **拷贝构造函数：**拷⻉构造函数的函数参数为对象本身的引用，用于根据⼀个已存在的对象复制出⼀个新的该类的对象，⼀般在函数中会将已存在的对象的数据成员的值⼀⼀复制到新创建的对象中。如果没有显示的写拷⻉构造函数，则系统会默认创建⼀个拷⻉构造函数，但当类中有指针成员时，最好不要使⽤编译器提供的默认的拷⻉构造函 数，最好⾃⼰定义并且在函数中执⾏深拷⻉。
> - **移动构造函数：**有时候我们会遇到这样一种情况，我们用对象 a 初始化对象 b 后对象 a 我们就不在使用了，但是对象 a 的空间还在呀（在析构之前），既然拷贝构造函数，实际上就是把 a 对象的内容复制一份到 b 中，那么为什么我们不能直接使用 a 的空间呢？这样就避免了新的空间的分配，大大降低了构造的成本。这就是移动构造函数设计的初衷。拷贝构造函数中，对于指针，我们一定要采用深层复制，而移动构造函数中，对于指针，我们采用浅层复制。
>
> > 但是指针的浅层复制是非常危险的。浅层复制之所以危险，是因为两个指针共同指向一片内存空间，若第一个指针将其释放，另一个指针的指向就不合法了（pointer dangling）。所以我们只要避免第一个指针释放空间就可以了。避免的方法就是将第一个指针（比如a->value）置为NULL，这样在调用析构函数的时候，由于有判断是否为NULL的语句，所以析构a的时候并不会回收a->value指向的空间（同时也是b->value指向的空间）
>
> - **赋值构造函数：**=运算符的重载，类似拷贝构造函数，将 = 右边的类对象赋值给类对象左边的对象，不属于构造函数，=两边的对象必须都要被创建。
>
> - **类型转换构造函数：**有时候不想要隐式转换，用explict关键字修饰。

## 左值和右值

> 左值：**可以取地址、位于赋值符号左边**的值，左值是表达式结束（不一定是赋值表达式）后依然存在的对象。
>
> 右值：可以提供数据值的表达式（不一定可以寻址，例如存储于寄存器中的数据）。如：
>
> 1. 字面值(字符串字面值除外)，例如1，'a', true等
> 2. 返回值为非引用的函数调用或操作符重载，例如：str.substr(1, 2), str1 + str2, or it++
> 3. 后置自增和自减表达式(a++, a--)
> 4. 算术表达式（x + y;）
> 5. 逻辑表达式
> 6. 比较表达式
> 7. 取地址表达式
> 8. lambda表达式`auto f = []{return 5;};`
>
> 右值又有纯右值和将亡值的说法。非引用返回的临时变量、运算表达式产生的临时变量、原始字面量和 lambda 表达式等都是纯右值。而将亡值是与右值引用相关的表达式，比如，将要被移动的对象、T&& 函数返回值、std::move 返回值和转换为 T&& 的类型的转换函数的返回值等。

## 左值引用和右值引用

> 右值引用是 C++11 中新增加的一个很重要的特性，他主是要用来解决 C++98/03 中遇到的两个问题
>
> - 第一个问题就是临时对象非必要的昂贵的拷贝操作
> - 第二个问题是在模板函数中如何按照参数的实际类型进行转发。
>
> 要拿到一个将亡值，就需要用到右值引用：`T &&`。右值引用的声明让这个临时值的生命周期得以延长、只要变量还活着，那么将亡值将继续存活。C++11 提供了 `std::move` 这个方法将左值参数无条件的转换为右值，有了它我们就能够方便的获得一个右值临时对象。

**移动语义**

> 右值引用的一个重要作用是用来支持移动语义的。那我们知道了移动语义是通过右值来匹配临时值的，那么很自然会想到，普通的左值是否也能借助移动语义来优化性能呢？C++11为了解决这个问题，提供了 std::move 方法来将左值转换为右值，从而方便应用移动语义。move是将对象资源的所有权从一个对象转移到另一个对象，只是转移，没有内存的拷贝，这就是所谓的 move 语义。
>
> move 实际上它并不能移动任何东西，它唯一的功能是将一个左值强制转换为一个右值引用。如果是一些基本类型比如 int 和 char[10] 定长数组等类型，使用 move 的话仍然会发生拷贝（因为没有对应的移动构造函数）。所以，move 对于含资源（堆内存或句柄）的对象来说更有意义。

**完美转发**

> 在函数模板中，完全依照模板的参数的类型（即保持参数的左值、右值特征），将参数传递给函数模板中调用的另外一个函数。C++11 中的 std::forward 正是做这个事情的，他会按照参数的实际类型进行转发。

## C++ 类型转换

> 1. **static_cast**：用于基本数据类型之间的转换，如：void*和其他类型指针之间的转换、子类对象的指针转换成父类对象指针。
>
>     最好把所有**隐式转换**都用 static_cast 代替
>
> 2. **const_cast**：用来移除变量的 const 特性，但是不能用于去除变量的常量性，而是去除指向对象的引用或指针的常量性，因此去除对象必须是指针或者引用。
>
>     - 指向常量的指针被转化成非常量指针，并且仍然指向原来的对象；
>
>     - 常量引用被转换成非常量引用，并且仍然指向原来的对象；
>
>     - 常量对象被转换成非常量对象。
>
> 3. **dynamic_cast**：不能用于内置类型转换，主要是继承关系的子类和父类之间的转换，一般是downcasting，向下强制转换。
>
>     子类指针指向父类指针，作用和 static_cast 一样，但将父类指针转化成子类指针，static_cast 可能会失败
>
>     **转换成功会返回引用或者指针，失败返回null**
>
> 4. **reinterpret_cast**：将任意类型指针转换为其他类型的指针。
>
>     改变指针或者引用的类型
>
>     - 将指针或者引用转换成一个足够长度的整型
>
>     - 将整型转换成指针或引用类型

## lambda 表达式

> **lambda 表达式特点**
>
> lambda 表达式定义了一个匿名函数，并且可以捕获一定范围内的变量。lambda 表达式的语法形式简单归纳如下：
>
> ```cpp
> [capture](params) opt -> ret {body;};
> ```
>
> 其中 `capture` 是捕获列表，`params` 是参数列表，`opt` 是函数选项，`ret` 是返回值类型，`body` 是函数体。
>
> 

## 智能指针

**为什么要使用智能指针？**

> 1. 防止内存泄漏：C++ 在堆上申请内存后，需要手动对内存进行释放。
> 2. 多线程下对象析构问题，造成这个问题本质的原因是类对象自己销毁(析构)的时候无法对自己加锁，所以要独立出来，采用这个中间层。

**shared_ptr**

> 共享所有权，也就是说多个指针可以指向一个相同的对象，当最后一个shared_ptr离开作用域的时候才会释放掉内存。
>
> **实现原理：**
> 在 shared_ptr 内部有一个共享引用计数器来自动管理，计数器实际上就是指向该资源指针的个数，每当复制一个 shared_ptr，引用计数会 + 1。当一个 shared_ptr 离开作用域时，引用计数会 - 1，当引用计数为 0 的时候，则 delete 内存。当计数器为0的时候指针才会彻底释放掉这个资源。

**weak_ptr**

> 它主要是为了配合 `shared_ptr` 而存在的。就像它的名字一样，它本身是一个弱指针，因为它本身是不能直接调用原生指针的方法的。如果想要使用原生指针的方法，需要将其先转换为一个 `shared_ptr`。
>
> 主要为了解决 `shared_ptr` 指针循环引用（a 对象持有 b 对象，b 对象持有 a 对象）造成的内存泄露问题，`weak_ptr` 不会增加引用计数，通过将循环引用中的一方修改为弱引用，可以避免内存泄漏。
>
> **方法**
>
> 1. expired() 判断所指向的原生指针是否被释放，如果被释放了返回 true，否则返回 false
> 2. use_count() 返回原生指针的引用计数
> 3. lock() 返回 shared_ptr，如果原生指针没有被释放，则返回一个非空的 shared_ptr，否则返回一个空的 shared_ptr
> 4. reset() 将本身置空

**unique_ptr**

> `unique_ptr `的核心特点就如它的名字一样，它拥有对持有对象的唯一所有权。即两个 `unique_ptr` 不能同时指向同一个对象，体现在：
>
> 1. `unique_ptr` 不能被复制到另外一个 `unique_ptr`
> 2. `unique_ptr` 所持有的对象只能通过转移语义将所有权转移到另外一个 `unique_ptr`

### shared_ptr，引用计数何时增加和减少

### 如何用普通指针初始化 shared_ptr，坏处？

- shared_ptr 如何实现
- 如何让多个 shared_ptr 对象共享引用计数
- shared_ptr 的使用可能造成内存泄露吗
- 
- shared_ptr 是线程安全的吗

# STL

## vector

### vector 增删改查复杂度分别是什么

### vector 支持越界检查吗

### vector 扩容机制，为什么倍增

### push_back 的复杂度一定是 O(1) 吗

### push_back 和 emplace_back 区别

> **使用 push_back() 函数需要调用拷贝构造函数和转移构造函数，而使用 emplace_back() 插入的元素原地构造，不需要触发拷贝构造和转移构造**，效率更高。

emplace_back 可以传对象吗

## map 和 unordered_map

map 除了查询复杂度高还有什么缺点

unordered_map 使用什么方法解决 hash 冲突

## stack 底层实现

- 