# C++ 基础知识

# C++ 11

## 智能指针

### 作用

避免在申请空间后忘记释放造成内存泄漏的问题，智能指针本身是一个类，当出了类作用域是会，会调用析构函数释放资源。所以其作用原理是在函数结束时自动释放内存空间，不需要手动释放。

### 使用

程序中需要包含的头文件：
```cpp
#include <memory>
```

使用智能指针初始化有几种方式：`new` 和 `make_shared`，使用 `make_share` 更安全，此函数在动态内存中分配一个对象并初始化它，返回指向此对象的 `shared_ptr` 

`shared_ptr`是一种引用计数型智能指针，引用计数顾名思义就是在内存中记录有多少个智能指针被引用，新增一个引用计数加一，过期引用计数则减一，当引用计数为0的时候，

例：

```cpp
#include <iostream>
#include <memory>

using namespace std;

class A {
public:
	A() {
  		cout << "A Constructor" << endl;
 	}
 ~	A() {
  		cout << "A Destruct" << endl;
 	}
};

void fun(shared_ptr<A>p) {   
    cout<<"fun count:"<<p.use_count()<<endl;
}

int main() {
 	shared_ptr<A> p = make_shared<A>();
 	cout << "count:"<<p.use_count() << endl; // 1
 	fun(p); // 2
    cout << "count:"<<p.use_count() << endl; // 1
 	return 0;
}
```

### 解决循环引用的问题

为什么会造成循环引用：

```cpp
#include <iostream>
#include <memory>

using namespace std;

class B;

class A {
public:
    shared_ptr<B>_pb;
};

class B {
public:
    shared_ptr<A>_pa;
};

int main() {
    shared_ptr<A>pa = make_shared<A>();
    shared_ptr<B>pb = make_shared<B>();
    cout<<"pa count:"<<pa.use_count()<<endl; // 1
     cout<<"pb count:"<<pb.use_count()<<endl; // 1
    pa->_pb = pb;
    pb->_pa = pa;
    cout<<"pa count:"<<pa.use_count()<<endl; // 2
    cout<<"pb count:"<<pb.use_count()<<endl; // 2
    return 0;
}
```

结束后，引用计数不为0，他们在堆上的空间不会被释放，造成==循环引用==

解决：使用 `weak_ptr`（不会增加引用计数）

```cpp
class A {
public:
    weak_ptr<B>_pb; // B同理
};
```

这样引用计数器不会加1，最后出作用域时调用析构函数，进行内存释放