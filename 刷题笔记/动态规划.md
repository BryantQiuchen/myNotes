# 动态规划问题类型

- 基础问题：斐波拉契数列、爬楼梯问题
- 01背包问题
- 打家劫舍
- 股票问题
- 子序列问题

**动态规划和贪心的区别：**
动态规划是由前一个状态推导出来的，而贪心是局部直接选最优

# 解题步骤

1. 确定dp数组以及下标的含义
2. 确定递推公式
3. dp数组如何初始化
4. 确定遍历顺序
5. 举例推导dp数组

# debug方式

1. 这道题目我举例推导状态转移公式了么？
2. 我打印dp数组的日志了么？
3. 打印出来了dp数组和我想的一样么？

# 01背包问题

有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。**每件物品只能用一次**，求解将哪些物品装入背包里物品价值总和最大。

背包最大重量为4。

物品为：

|       | 重量 | 价值 |
| :---: | :--: | :--: |
| 物品0 |  1   |  15  |
| 物品1 |  3   |  20  |
| 物品2 |  4   |  30  |

## 二维dp数组

五部曲进行分析：

1. 确定dp数组以及下标的含义

    对于背包问题，有一种写法， 是使用二维数组，即**`dp[i][j]`表示从下标为[0 - i]的物品里任意取，放进容量为 j 的背包，价值总和最大是多少**。

    ![动态规划-背包问题1](https://img-blog.csdnimg.cn/20210110103003361.png)

2. 确定递推公式

    - **不放物品i**：由`dp[i - 1][j]`推出，即背包容量为 j ，里面不放物品i的最大价值，此时`dp[i][j]`就是`dp[i - 1][j]`。(其实就是当物品 i 的重量大于背包 j 的重量时，物品i 无法放进背包中，所以被背包内的价值依然和前面相同。)

    - **放物品i**：由`dp[i - 1][j - weight[i]]`推出，`dp[i - 1][j - weight[i]] `为背包容量为`j - weight[i]`的时候不放物品i的最大价值，那么`dp[i - 1][j - weight[i]] + value[i]` （物品i的价值），就是背包放物品 i 得到的最大价值

    - 递归公式： 

        ```cpp
        dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);
        ```

3. dp数组如何初始化

    `dp[i][0] = 0`，同时第 1 行也需要初始化

    ![动态规划-背包问题10](https://code-thinking.cdn.bcebos.com/pics/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%9810.jpg)

    ```cpp
    // 初始化 dp
    vector<vector<int>> dp(weight.size(), vector<int>(bagweight + 1, 0));
    for (int j = weight[0]; j <= bagweight; j++) {
        dp[0][j] = value[0];
    }
    ```

4. 确定遍历顺序

    先遍历物品，再遍历背包重量

    ```cpp
    // weight数组的大小 就是物品个数
    for(int i = 1; i < weight.size(); i++) { // 遍历物品
        for(int j = 0; j <= bagweight; j++) { // 遍历背包容量
            if (j < weight[i]) dp[i][j] = dp[i - 1][j]; 
            else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);
        }
    }
    ```

    先遍历背包，再遍历物品

    ```cpp
    // weight数组的大小 就是物品个数
    for(int j = 0; j <= bagweight; j++) { // 遍历背包容量
        for(int i = 1; i < weight.size(); i++) { // 遍历物品
            if (j < weight[i]) dp[i][j] = dp[i - 1][j];
            else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);
        }
    }
    ```

5. 举例推导dp数组

## 一维dp数组（滚动数组）

1. 确定dp数组以及下标的含义

    一维数组中，dp[j] 表示容量为 j 的背包，所背的物品价值可以最大为 dp[j]

2. 确定递推公式

    dp[j]可以通过`dp[j - weight[i]]`推导出来，`dp[j - weight[i]]`表示容量为`j - weight[i]`的背包所背的最大价值。

    `dp[j - weight[i]] + value[i] `表示 容量为 j - 物品i重量 的背包 加上 物品i的价值。（也就是容量为j的背包，放入物品i了之后的价值即：dp[j]）

    递推公式

    ```cpp
    dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
    ```

3. dp数组如何初始化

    初始化为0，dp数组在推导中一定是取价值最大的数。

4. 确定遍历顺序

    ```cpp
    for(int i = 0; i < weight.size(); i++) { // 遍历物品
        for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量(倒序)
            dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
        }
    }
    ```

5. 举例推导dp数组

# 完全背包问题

有N件物品和一个最多能背重量为W的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。**每件物品都有无限个（也就是可以放入背包多次）**，求解将哪些物品装入背包里物品价值总和最大。

**完全背包和01背包问题唯一不同的地方就是，每种物品有无限件**。

01背包和完全背包唯一不同就是体现在遍历顺序上，01背包的核心代码为：

```cpp
for(int i = 0; i < weight.size(); i++) { // 遍历物品
    for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量
        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
    }
}
```

完全背包中物品可以取得多次，代码只需要进行一点修改即可，即从小到大进行遍历，在01背包中不能从小到大遍历，因为物品会被多次重复的加入背包。

```cpp
// 先遍历物品，再遍历背包
for(int i = 0; i < weight.size(); i++) { // 遍历物品
    for(int j = weight[i]; j <= bagWeight ; j++) { // 遍历背包容量
        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
    }
}
```

# 多重背包问题

有N种物品和一个容量为V 的背包。第i种物品最多有Mi件可用，每件耗费的空间是Ci ，价值是Wi 。求解将哪些物品装入背包可使这些物品的耗费的空间 总和不超过背包容量，且价值总和最大。

与01背包问题相似：每件物品最多有Mi件可用，把Mi件摊开，其实就是一个01背包问题了。

例如：

背包最大重量为10。

物品为：

|       | 重量 | 价值 | 数量 |
| ----- | ---- | ---- | ---- |
| 物品0 | 1    | 15   | 2    |
| 物品1 | 3    | 20   | 3    |
| 物品2 | 4    | 30   | 2    |

和下面的01背包问题相似：

| 重量  | 价值 | 数量 |      |
| ----- | ---- | ---- | ---- |
| 物品0 | 1    | 15   | 1    |
| 物品0 | 1    | 15   | 1    |
| 物品1 | 3    | 20   | 1    |
| 物品1 | 3    | 20   | 1    |
| 物品1 | 3    | 20   | 1    |
| 物品2 | 4    | 30   | 1    |
| 物品2 | 4    | 30   | 1    |

毫无区别，这就转成了一个01背包问题了，且每个物品只用一次。

# 买卖股票

1. 确定dp数组以及下标的含义

    `dp[i][0]` 表示第i天持有股票所得最多现金 ，一开始现金是0，那么加入第i天买入股票现金就是 `-prices[i]`， 这是一个负数。

    `dp[i][1] `表示第i天不持有股票所得最多现金

    **注意这里说的是“持有”，“持有”不代表就是当天“买入”！也有可能是昨天就买入了，今天保持持有的状态**

2. 确定递推公式

    分情况讨论：

    如果第i天持有股票即`dp[i][0]`， 那么可以由两个状态推出来

    - 第i-1天就持有股票，那么就保持现状，所得现金就是昨天持有股票的所得现金 即：`dp[i - 1][0]`
    - 第i天买入股票，所得现金就是买入今天的股票后所得现金即：`-prices[i]`

    `dp[i][0] = max(dp[i - 1][0], -prices[i]);` 

    如果第i天不持有即`dp[i][1]`

    - 第i-1天就不持有股票，那么就保持现状，所得现金就是昨天不持有股票的所得现金 即：`dp[i - 1][1]`
    - 第i天卖出股票，所得现金就是按照今天股票佳价格卖出后所得现金即：`prices[i] + dp[i - 1][0]`

    `dp[i][1] = max(dp[i - 1][1], prices[i] + dp[i - 1][0]);`

3. dp数组如何初始化

    从上两种情况的递推公式来看，都是从`dp[0][0]`和`dp[0][1]`推导出来的

    那么`dp[0][0]`表示第0天持有股票，此时的持有股票就一定是买入股票了，因为不可能有前一天推出来，所以`dp[0][0] -= prices[0];`

    `dp[0][1]`表示第0天不持有股票，不持有股票那么现金就是0，所以`dp[0][1] = 0;`

4. 确定遍历顺序

    显然是从前往后遍历

5. 举例推导dp数组

