# 链表

定义一个单链表

```cpp
struct ListNode {
	int val;
    ListNode *next;
    ListNode(int x) : val(x), next(nullptr) {} // 节点构造函数
};
// 初始化节点
ListNode *head = new ListNode(0);
```

## 经典题目

### 链表基本操作

设计链表（LC.707）

设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：`val` 和 `next`。v假设链表中的所有节点都是 `0-index` 的。

在链表类中实现这些功能：

- `get(index)`：获取链表中第 `index` 个节点的值。如果索引无效，则返回-1。
- `addAtHead(val)`：在链表的第一个元素之前添加一个值为 `val` 的节点。插入后，新节点将成为链表的第一个节点。
- `addAtTail(val)`：将值为 `val` 的节点追加到链表的最后一个元素。
- `addAtIndex(index,val)`：在链表中的第 `index` 个节点之前添加值为 `val`  的节点。如果` index` 等于链表的长度，则该节点将附加到链表的末尾。如果 `index` 大于链表长度，则不会插入节点。如果`index`小于0，则在头部插入节点。
- `deleteAtIndex(index)`：如果索引 `index` 有效，则删除链表中的第 `index` 个节点。

```cpp
class MyLinkedList {
public:
// 定义节点
    struct ListNode {
        int val;
        ListNode *next;
        ListNode(int x) : val(x), next(nullptr) {}
    };

// 对链表进行初始化
    MyLinkedList() {
        dummyHead = new ListNode(-1); // 虚拟头节点
        listLength = 0; // 链表长度
    }

// 获取链表中第index个节点的值，索引无效返回-1
    int get(int index) {
        if (index < 0 || index > listLength - 1) return -1;
        ListNode *cur = dummyHead->next;
        while (index -- ) {
            cur = cur->next;
        }
        return cur->val;
    }
    
// 在链表的第一个元素之前添加一个值为val的节点，插入后，新节点是链表的第一个节点
    void addAtHead(int val) {
        ListNode *newNode = new ListNode(val);
        newNode->next = dummyHead->next;
        dummyHead->next = newNode;
        listLength ++ ;
    }
    
// 将值为 val 的节点追加到链表的最后一个元素。
    void addAtTail(int val) {
        ListNode *newNode = new ListNode(val);
        ListNode *temp = dummyHead;
        while(temp->next) {
            temp = temp->next;
        }
        temp->next = newNode;
        listLength ++ ;
    }

// 在链表中的第 index 个节点之前添加值为 val的节点，index大于链表长度，不会插入了节点，小于0，在头部插入
    void addAtIndex(int index, int val) {
        if (index > listLength) return;
        ListNode *cur = dummyHead;
        ListNode *newNode = new ListNode(val);
        while (index -- ) {
            cur = cur->next;
        }
        newNode->next = cur->next;
        cur->next = newNode;
        listLength ++ ;
    }

// 如果索引 index 有效，则删除链表中的第 index 个节点。
    void deleteAtIndex(int index) {
        if (index < 0 || index > listLength - 1) return;
        ListNode *cur = dummyHead;
        while (index -- ) {
            cur = cur->next;
        }
        ListNode *temp = cur->next;
        cur->next = cur->next->next;
        delete temp;
        listLength -- ;
    }

private:
    int listLength;
    ListNode *dummyHead;
};
```

### 虚拟头节点

移除链表元素（LC.203）

给你一个链表的头节点 `head` 和一个整数 `val` ，请你删除链表中所有满足 `Node.val == val` 的节点，并返回 **新的头节点** 。

```cpp
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        ListNode* dummy = new ListNode(-1);	// 虚拟头节点
        dummy->next = head;
        ListNode* t = dummy;
        while(t->next != nullptr) {
            if(t->next->val == val) {
                ListNode* temp = t->next;
                t->next = t->next->next;
                delete temp;
            }
            else {
                t = t->next;
            }
        }
        return dummy->next; // 注意返回的是dummy->next
    }
};
```

### 反转链表

反转链表（LC.206)

给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。

```cpp
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode *dummy = new ListNode(-1);	// 同样定义了虚拟的头节点	
        ListNode *cur = head;
        while (cur != nullptr) {
            ListNode *temp = cur->next;
            cur->next = dummy->next;
            dummy->next = cur;
            cur = temp;
        }
        return dummy->next;
    }
};
```

### 链表相交

链表相交（面试题 02.07）

给你两个单链表的头节点 `headA` 和 `headB` ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 `null` 。

题目数据 **保证** 整个链式结构中不存在环。

**注意**，函数返回结果后，链表必须 **保持其原始结构** 。

（使用双指针）

```cpp
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        ListNode *A = headA, *B = headB;
        while (A != B) {
            A = A != nullptr ? A->next : headB;	// A空 A到B头
            B = B != nullptr ? B->next : headA;	// B空 B到A头
        }
        return A;
    }
};
```

# 回溯问题

|    类型    |                             题目                             |
| :--------: | :----------------------------------------------------------: |
| 子集、组合 | [子集](https://leetcode-cn.com/problems/subsets/)、[子集 II](https://leetcode-cn.com/problems/subsets-ii/)、[组合](https://leetcode-cn.com/problems/combinations/)、[组合总和](https://leetcode-cn.com/problems/combination-sum/)、[组合总和 II](https://leetcode-cn.com/problems/combination-sum-ii/) |
|   全排列   | [全排列](https://leetcode-cn.com/problems/permutations/)、[全排列 II](https://leetcode-cn.com/problems/permutations-ii/)、[字符串的全排列](https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/)、[字母大小写全排列](https://leetcode-cn.com/problems/letter-case-permutation/) |
|    搜索    | [解数独](https://leetcode-cn.com/problems/sudoku-solver/)、[单词搜索](https://leetcode-cn.com/problems/word-search/)、[N皇后](https://leetcode-cn.com/problems/eight-queens-lcci/)、[分割回文串](https://leetcode-cn.com/problems/palindrome-partitioning/)、[二进制手表](https://leetcode-cn.com/problems/binary-watch/) |

子集、组合无关顺序，而排列和顺序有关，对于`[1,2]和[2,1]`，对于子集问题来说是同一个子集，但确是两种排列方式
