**反转字符串函数**

```cpp
// 反转字符串s中左闭又闭的区间[start, end], 库函数reverse区间左闭右开[start, end)
void reverse(string& s, int start, int end) {
	for (int i = start, j = end; i < j; i++, j--) {
		swap(s[i], s[j]);
	}
}
```

# 344. 反转字符串 [easy]

编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。

不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。

**示例 1：**

```
输入：s = ["h","e","l","l","o"]
输出：["o","l","l","e","h"]
```

**示例 2：**

```
输入：s = ["H","a","n","n","a","h"]
输出：["h","a","n","n","a","H"]
```

**提示：**

- `1 <= s.length <= 105`
- `s[i]` 都是 [ASCII](https://baike.baidu.com/item/ASCII) 码表中的可打印字符

**思路：**

对于字符串，我们定义两个指针（也可以说是索引下标），一个从字符串前面，一个从字符串后面，两个指针同时向中间移动，并交换元素。

**题解**：

```cpp
class Solution {
public:
    void reverseString(vector<char>& s) {
        for (int i = 0, j = s.size() - 1; i < s.size()/2; i++, j--) {
            swap(s[i],s[j]);
        }
    }
};
// swap可以通过位运算来完成: a = a ^ b, b = b ^ a, a = a ^ b;

```

# 541. 反转字符串 II [easy]

给定一个字符串 s 和一个整数 k，从字符串开头算起，每计数至 2k 个字符，就反转这 2k 字符中的前 k 个字符。

如果剩余字符少于 k 个，则将剩余字符全部反转。
如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。

**示例 1：**

```
输入：s = "abcdefg", k = 2
输出："bacdfeg"
```

**示例 2：**

```
输入：s = "abcd", k = 2
输出："bacd"
```

**提示：**

- `1 <= s.length <= 104`
- `s` 仅由小写英文组成
- `1 <= k <= 104`

**思路**：

每隔2k个字符的前k的字符，写了一堆逻辑代码或者再搞一个计数器，来统计2k，再统计前k个字符。其实在遍历字符串的过程中，只要让 `i+= (2 * k)`，i 每次移动 `2 * k` 就可以了，然后判断是否需要有反转的区间。因为要找的也就是每`2 * k` 区间的起点，这样写，程序会高效很多。

**题解：**

```cpp
class Solution {
public:
    string reverseStr(string s, int k) {
        for (int i = 0; i < s.size(); i += 2 * k ) {
            if (i + k <= s.size()) {
                reverse(s.begin() + i, s.begin() + k + i); // reverse 库函数，左闭右开
                continue;
            }
            reverse(s.begin() + i, s.end());
        }
        return s;
    }
};
```

# 剑指 Offer 05: 替换空格

请实现一个函数，把字符串 `s` 中的每个空格替换成"%20"。

**示例 1：**

```
输入：s = "We are happy."
输出："We%20are%20happy."
```

**限制：**

```
0 <= s 的长度 <= 10000
```

**思路：**

首先扩充数组到每个空格替换成"%20"之后的大小。

然后从后向前替换空格，也就是双指针法，过程如下：**i指向新长度的末尾，j指向旧长度的末尾**。

从后往前填充；

从前向后填充就是$O(n^2)$的算法了，因为每次添加元素都要将添加元素之后的所有元素向后移动。**其实很多数组填充类的问题，都可以先预先给数组扩容带填充后的大小，然后在从后向前进行操作。**

这么做有两个好处：

1. 不用申请新数组。
2. 从后向前填充元素，避免了从前先后填充元素要来的 每次添加元素都要将添加元素之后的所有元素向后移动。

**题解：**

```cpp
class Solution {
public:
    string replaceSpace(string s) {
        int count = 0, len = s.size();
        for (char c : s) {
            if (c == ' ') count++;
        }
        s.resize(len + 2 * count);
        for(int i = len - 1, j = s.size() - 1; i < j; i--, j--) {
            if (s[i] != ' ')
                s[j] = s[i];
            else {
                s[j - 2] = '%';
                s[j - 1] = '2';
                s[j] = '0';
                j -= 2;
            }
        }
        return s;
    }
};
```

# 151. 翻转字符串里的单词 [medium]

给你一个字符串 s ，逐个翻转字符串中的所有 单词 。

单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。

请你返回一个翻转 s 中单词顺序并用单个空格相连的字符串。

说明：

输入字符串 s 可以在前面、后面或者单词间包含多余的空格。
翻转后单词间应当仅用一个空格分隔。
翻转后的字符串中不应包含额外的空格。

**示例 1：**

```
输入：s = "the sky is blue"
输出："blue is sky the"
```

**示例 2：**

```
输入：s = "  hello world  "
输出："world hello"
解释：输入字符串可以在前面或者后面包含多余的空格，但是翻转后的字符不能包括。
```

**示例 3：**

```
输入：s = "a good   example"
输出："example good a"
解释：如果两个单词间有多余的空格，将翻转后单词间的空格减少到只含一个。
```

**示例 4：**

```
输入：s = "  Bob    Loves  Alice   "
输出："Alice Loves Bob"
```

**示例 5：**

```
输入：s = "Alice does not even like bob"
输出："bob like even not does Alice"
```

**思路：**

**不要使用辅助空间，空间复杂度要求为$O(1)$**

想一下，我们将整个字符串都反转过来，那么单词的顺序指定是倒序了，只不过单词本身也倒序了，那么再把单词反转一下，单词不就正过来了。

所以解题思路如下：

- 移除多余空格
- 将整个字符串反转
- 将每个单词反转

举个例子，源字符串为："the sky is blue "

- 移除多余空格 : "the sky is blue"
- 字符串反转："eulb si yks eht"
- 单词反转："blue is sky the"

这样我们就完成了翻转字符串里的单词。

使用`erase()`方法，从前向后遍历，遇到空格`' '`就`erase`，一个erase操作就是$O(n)$，还需要再外多套一个`for`循环，整体就变成了$O(n^2)$的复杂度；而使用双指针去除空格，复杂度可以降为$O(n)$

**题解：**

```cpp
class Solution {
public:
    // 反转字符串s中左闭又闭的区间[start, end]
    void reverse(string& s, int start, int end) {
        for (int i = start, j = end; i < j; i++, j--) {
            swap(s[i], s[j]);
        }
    }

    // 移除冗余空格：使用双指针（快慢指针法）O(n)的算法
    void removeExtraSpaces(string& s) {
        int slowIndex = 0, fastIndex = 0; // 定义快指针，慢指针
        // 去掉字符串前面的空格
        while (s.size() > 0 && fastIndex < s.size() && s[fastIndex] == ' ') {
            fastIndex++;
        }
        for (; fastIndex < s.size(); fastIndex++) {
            // 去掉字符串中间部分的冗余空格
            if (fastIndex - 1 > 0
                    && s[fastIndex - 1] == s[fastIndex]
                    && s[fastIndex] == ' ') {
                continue;
            } else {
                s[slowIndex++] = s[fastIndex];
            }
        }
        if (slowIndex - 1 > 0 && s[slowIndex - 1] == ' ') { // 去掉字符串末尾的空格
            s.resize(slowIndex - 1);
        } else {
            s.resize(slowIndex); // 重新设置字符串大小
        }
    } 
    
    string reverseWords(string s) {
        removeExtraSpaces(s);
        reverse(s, 0, s.size() - 1);
        for(int i = 0; i < s.size(); i++) {
            int j = i;
            // 查找单词间的空格，翻转单词
            while(j < s.size() && s[j] != ' ') j++;
            reverse(s, i, j - 1);
            i = j;
        }
        return s;
    }
};
```

# 剑指Offer58-II. 左旋转字符串 [easy]

字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串"abcdefg"和数字2，该函数将返回左旋转两位得到的结果"cdefgab"。

**示例 1：**

```
输入: s = "abcdefg", n = 2
输出: "cdefgab"
```

**示例 2 :** 

```
输入: s = "lrloseumgh", n = 6
输出: "umghlrlose"
```

**限制：**

- `1 <= n < s.length <= 10000`

**思路：**

为了让本题更有意义，提升一下本题难度：**不能申请额外空间，只能在本串上操作**。

和上一题目类似，可以通过局部反转+整体反转。这道题目也非常类似，依然可以通过局部反转+整体反转达到左旋转的目的。

具体步骤为：

1. 反转区间为前n的子串
2. 反转区间为n到末尾的子串
3. 反转整个字符串

**题解**：

```cpp
class Solution {
public:
    string reverseLeftWords(string s, int n) {
        reverse(s.begin(), s.begin() + n);  //反转前n个子串
        reverse(s.begin() + n, s.end());    //反转n到末尾的子串
        reverse(s.begin(), s.end());
        return s;
    }
};
```

```cpp
//通过字符串遍历拼接，在原本的字符串上申请了额外的空间
class Solution {
public:
    string reverseLeftWords(string s, int n) {
        for(int i=0;i<n;i++){
            s.push_back(s[i]);
        }
        s.erase(0,n);
        return s;
    }
};
```

# 28. 实现 strStr() [easy]

实现 `strStr() `函数。

给你两个字符串 `haystack` 和 `needle `，请你在` haystack `字符串中找出` needle `字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回  -1 。

说明：

当 `needle `是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。

对于本题而言，当` needle `是空字符串时我们应当返回 0 。这与 C 语言的 `strstr() `以及 Java 的 `indexOf() `定义相符。

**示例 1：**

```
输入：haystack = "hello", needle = "ll"
输出：2
```

**示例 2：**

```
输入：haystack = "aaaaa", needle = "bba"
输出：-1
```

**示例 3：**

```
输入：haystack = "", needle = ""
输出：0
```

提示：

- `0 <= haystack.length, needle.length <= 5 * 10^4`
- `haystack `和 `needle `仅由小写英文字符组成

**思路：**

**方法一：暴力匹配**

我们可以让字符串 `needle` 与字符串 `haystack` 的所有长度为 `m` 的子串均匹配一次。

为了减少不必要的匹配，我们每次匹配失败即立刻停止当前子串的匹配，对下一个子串继续匹配。如果当前子串匹配成功，我们返回当前子串的开始位置即可。如果所有子串都匹配失败，则返回 -1。

时间复杂度：$O(mn)$，m和n分别为字符串 `needle` 与字符串 `haystack` 的长度。

**方法二：KMP算法**

文章中字符串的**前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串；后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串**。

**题解：**

```cpp
// 暴力解法
class Solution {
public:
    int strStr(string s, string p) {
        int n = s.size(), m = p.size();
        for(int i = 0; i <= n - m; i++){
            int j = i, k = 0; 
            while(k < m and s[j] == p[k]){
                j++;
                k++;
            }
            if(k == m) return i;
        }
        return -1;
    }
};
```

**KMP算法，维护next数组**

```cpp
class Solution {
public:
    void getNext(int* next, const string& s) {	
        int j = 0;
        next[0] = 0;
        for(int i = 1; i < s.size(); i++) {
            while (j > 0 && s[i] != s[j]) {		// 不匹配，前后不相等，开始回退
                j = next[j - 1];				// 注意：while循环！！
            }
            if (s[i] == s[j]) {
                j++;							// 找到相同的前后缀
            }
            next[i] = j;						// 将j（前缀的长度）赋给next[i]
        }
    }
    int strStr(string haystack, string needle) {
        if (needle.size() == 0) {
            return 0;
        }
        int next[needle.size()];
        getNext(next, needle);
        int j = 0;
        for (int i = 0; i < haystack.size(); i++) {
            while(j > 0 && haystack[i] != needle[j]) {
                j = next[j - 1];
            }
            if (haystack[i] == needle[j]) {
                j++;
            }
            if (j == needle.size() ) {
                return (i - needle.size() + 1);
            }
        }
        return -1;
    }
};
```

# 459. 重复的子字符串 [easy]

给定一个非空的字符串 `s` ，检查是否可以通过由它的一个子串重复多次构成。

**示例 1:**

```
输入: s = "abab"
输出: true
```

**示例 2:**

```
输入: s = "aba"
输出: false
```

**示例 3:**

```
输入: s = "abcabcabcabc"
输出: true
解释: 可由子串 "abc" 重复四次构成。 (或子串 "abcabc" 重复两次构成。)
```

**提示：**

- `1 <= s.length <= 104`
- `s` 由小写英文字母组成

**思路：**

KMP算法

**数组长度减去最长相同前后缀的长度相当于是第一个周期的长度，也就是一个周期的长度，如果这个周期可以被整除，就说明整个数组就是这个周期的循环。**

**题解：**

```cpp
class Solution {
public:
    void getNext(int* next, const string& s) {
        int j = 0;
        next[0] = 0;
        for(int i = 1; i < s.size(); i++) {
            while (j > 0 && s[i] != s[j]) {
                j = next[j - 1];
            }
            if (s[i] == s[j]) {
                j++;
            }
            next[i] = j;
        }
    }
    bool repeatedSubstringPattern(string s) {
        int len = s.size();
        int next[len];
        getNext(next, s);
        if (next[len - 1] != 0 && len % (len - (next[len - 1] )) == 0) {    
            //最后一位大于0 且要长度要满足一个子串的倍数
            return true;
        }
        return false;
    }
};
```

# 242. 有效的字母异位词 [easy]

给定两个字符串 `s` 和 `t` ，编写一个函数来判断  `s` 是否是 `t`  的字母异位词。

**注意：**若  `s` 和 `t`  中每个字符出现的次数都相同，则称  `s` 和 `t`  互为字母异位词。

**示例 1:**

```
输入: s = "anagram", t = "nagaram"
输出: true
```

**示例 2:**

```
输入: s = "rat", t = "car"
输出: false
```

**提示:**

- `1 <= s.length, t.length <= 5 * 104`
- `s` 和 `t` 仅包含小写字母

**思路**：

构建一个数组 counts 统计两个数组中的字母出现的频次，如果频次相同，说明他们之间出现的次数都相同。

（Unicode 是为了解决传统字符编码的局限性而产生的方案，它为每个语言中的字符规定了一个唯一的二进制编码。）

**题解：**

```cpp
class Solution {
public:
    bool isAnagram(string s, string t) {
        vector<int> counts(26, 0);
        if (s.size() != t.size()) return false;
        for (int i = 0; i < s.size(); i ++) {
            counts[s[i] - 'a']++;
            counts[t[i] - 'a']--;
        }
        for (int i = 0; i < 26; i ++) {
            if (counts[i]) return false;
        }
        return true;
    }
};
```

# 205. 同构字符串 [easy]

给定两个字符串 `s` 和 `t` ，判断它们是否是同构的。

如果 `s` 中的字符可以按某种映射关系替换得到 `t` ，那么这两个字符串是同构的。

每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。不同字符不能映射到同一个字符上，相同字符只能映射到同一个字符上，字符可以映射到自己本身。

**示例 1:**

```
输入：s = "egg", t = "add"
输出：true
```

**示例 2：**

```
输入：s = "foo", t = "bar"
输出：false
```

**示例 3：**

```
输入：s = "paper", t = "title"
输出：true
```

**提示：**

- `1 <= s.length <= 5 * 104`
- `t.length == s.length`
- `s` 和 `t` 由任意有效的 ASCII 字符组成

**思路：**

记录两个字符串每个位置的字符第一次出现的位置，如果两个字符串中相同位置的字符与它们第一次出现的位置一样，那么这两个字符串同构。举例来说，对于“paper”和“title”，假设我们现在遍历到第三个字符“p”和“t”，发现它们第一次出现的位置都在第一个字符，则说明目前位置满足同构。

**题解：**

```cpp
class Solution {
public:
    bool isIsomorphic(string s, string t) {
        vector<int> s_first_index(256, 0), t_first_index(256, 0); 
        // ASCII码 总共字符256个
        for (int i = 0; i < s.length(); ++i) {
            if (s_first_index[s[i]] != t_first_index[t[i]]) {   
  		// 映射到ascii值，虽然vector中存放的是int，但每个字符可以转化为其对应的ascii值
                return false;
            }
            s_first_index[s[i]] = t_first_index[t[i]] = i + 1;
        }
        return true;
    }
};
```

# 647. 回文子串 [medium]

给你一个字符串 `s `，请你统计并返回这个字符串中 **回文子串** 的数目。

**回文字符串** 是正着读和倒过来读一样的字符串。

**子字符串** 是字符串中的由连续字符组成的一个序列。

具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。

**示例 1：**

```
输入：s = "abc"
输出：3
解释：三个回文子串: "a", "b", "c"
```

**示例 2：**

```
输入：s = "aaa"
输出：6
解释：6个回文子串: "a", "a", "a", "aa", "aa", "aaa"
```

**提示：**

- `1 <= s.length <= 1000`
- `s` 由小写英文字母组成

**思路：**

对字符串中的每个字符，从中间向两边扩散，找回文子串，需要分奇数长度和偶数长度

**题解：**

```cpp
class Solution {
public:
    int countSubstrings(string s) {
        int count = 0;
        for (int i = 0; i < s.length(); ++i) {
            count += extendSubstrings(s, i, i); // 奇数长度
            count += extendSubstrings(s, i, i + 1); // 偶数长度
        }
        return count;
    }
    int extendSubstrings(string s, int l, int r) {
        int count = 0;
        while (l >= 0 && r < s.length() && s[l] == s[r]) {
            --l;
            ++r;
            ++count;
        }
        return count;
    }
};
```

# 696. 计数二进制子串 [easy]

给定一个字符串 `s`，统计并返回具有相同数量 `0` 和 `1` 的非空（连续）子字符串的数量，并且这些子字符串中的所有 `0` 和所有 `1` 都是成组连续的。

重复出现（不同位置）的子串也要统计它们出现的次数。

**示例 1：**

```
输入：s = "00110011"
输出：6
解释：6 个子串满足具有相同数量的连续 1 和 0 ：
"0011"、"01"、"1100"、"10"、"0011" 和 "01" 。
注意，一些重复出现的子串（不同位置）要统计它们出现的次数。
另外，"00110011" 不是有效的子串，因为所有的 0（还有 1 ）没有组合在一起。
```

**示例 2：**

```
输入：s = "10101"
输出：4
解释：有 4 个子串："10"、"01"、"10"、"01" ，具有相同数量的连续 1 和 0 。
```

**提示：**

- `1 <= s.length <= 105`
- `s[i]` 为 `'0'` 或 `'1'`

**思路：**

从左往右遍历数组，记录和当前位置数字相同且连续的长度，以及其之前连续的不同数字的长度。举例来说，对于 00110 的最后一位，我们记录的相同数字长度是 1，因为只有一个连续 0；我们记录的不同数字长度是 2，因为在 0 之前有两个连续的 1。若不同数字的连续长度大于等于当前数字的连续长度，则说明存在一个且只存在一个以当前数字结尾的满足条件的子字符串。

**题解：**

```cpp
class Solution {
public:
    int countBinarySubstrings(string s) { 
// 从左往右遍历数组，记录和当前位置数字相同且连续的长度，以及其之前连续的不同数字的长度。
        int pre = 0, cur = 1, counts = 0;
        for (int i = 1; i < s.size(); i ++ ) {
            if(s[i] == s[i - 1]) cur ++;
            else {	
// 当前数和前一个数不相等，需要修改pre和cur，当前位置数字相同且连续的长度设为1；
                pre = cur;	
                cur = 1;
            }
// 前面的数字连续长度大于当前数字连续长度，说明存在满足条件的子字符串。
            if (pre >= cur) counts ++;
        }
        return counts;
    }
};
```

# 227. 基本计算器 II [medium]

给你一个字符串表达式 `s` ，请你实现一个基本计算器来计算并返回它的值。

整数除法仅保留整数部分。

**示例 1：**

```
输入：s = "3+2*2"
输出：7
```

**示例 2：**

```
输入：s = " 3/2 "
输出：1
```

**示例 3：**

```
输入：s = " 3+5 / 2 "
输出：5
```

**提示：**

- `1 <= s.length <= 3 * 105`
- `s` 由整数和算符 `('+', '-', '*', '/')` 组成，中间由一些空格隔开
- `s` 表示一个 **有效表达式**
- 表达式中的所有整数都是非负整数，且在范围 `[0, 231 - 1]` 内
- 题目数据保证答案是一个 **32-bit 整数**

**思路：**

这道题主要是需要考虑加减和乘除的优先级问题，用栈来处理，遇到加减就把数字压栈，遇到乘除就把栈顶弹出，与数字进行乘除处理。主要注意的是运算符是放在两个数字的中间，而我们想要的是在遇到运算符时，用于运算的两个数字已经被解析出来了，因此用sign来记录前一个运算符，在遇到一个新的运算符或者到字符串的结尾时再考虑对前一个运算符进行处理。

**题解：**

```cpp
class Solution {
public:
    int calculate(string s) {
        if(s.size()==0)
            return 0;
        int res = 0;
        stack<int>stk;
        int num = 0;
        char sign = '+';
        for(int i = 0;i<s.size();i++){
            if(s[i] >= '0' && s[i] <= '9'){
                // 如果字符串中数字不是一位，例如42，需要输出为int型的
                num *= 10;		
                num = num - '0' + s[i];
            }
            if((s[i]=='+'||s[i]=='-'||s[i]=='*'||s[i]=='/')||i==s.size()-1){
                if(sign=='+')
                    stk.push(num);
                if(sign=='-')
                    stk.push(-num);
                if(sign=='*'){	// 乘法，先把栈顶的出栈，再和num作乘法
                    int topnum = stk.top();
                    stk.pop();
                    stk.push(num*topnum);
                }
                if(sign=='/'){
                    int topnum = stk.top();
                    stk.pop();
                    stk.push(topnum/num);
                }
                sign=s[i];
                num = 0;
            }
        }
        while(!stk.empty()){
            int topnum = stk.top();
            res += topnum;
            stk.pop();
        }
        return res;
    }
};
```

# 409. 最长回文串 [medium]

给定一个包含大写字母和小写字母的字符串 `s` ，返回 *通过这些字母构造成的 **最长的回文串*** 。

在构造过程中，请注意 **区分大小写** 。比如 `"Aa"` 不能当做一个回文字符串。

**示例 1:**

```
输入:s = "abccccdd"
输出:7
解释:
我们可以构造的最长的回文串是"dccaccd", 它的长度是 7。
```

**示例 2:**

```
输入:s = "a"
输入:1
```

**示例 3:**

```
输入:s = "bb"
输入: 2
```

**提示:**

- `1 <= s.length <= 2000`
- `s` 只能由小写和/或大写英文字母组成

**思路：**

计算 s 里的每个字符出现的数量，用一个哈希表来维护，`key`是字符，`value`是字符出现的个数，出现次数为奇数的数再分情况讨论

**题解：**

```cpp
class Solution {
public:
    int longestPalindrome(string s) {   //string 字符串，char 字符
        unordered_map<char, int> count;
        int ans = 0;
        for (char c : s)
            count[c] ++;
        for (auto p : count) {
            int v = p.second;
            ans += v / 2 * 2;						
            if (v % 2 == 1 and ans % 2 == 0)	// 出现次数为奇数
                ++ans;
        }
        return ans;
    }
};
```

# 3. 无重复字符的最长子串 [medium]

给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长子串** 的长度。

**示例 1:**

```
输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```

**示例 2:**

```
输入: s = "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
```

**示例 3:**

```
输入: s = "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。 
	 请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
```

**提示：**

- `0 <= s.length <= 5 * 104`
- `s` 由英文字母、数字、符号和空格组成

**思路：**

滑动窗口法，设两个指针，看后面的指针指向的数在前面的数组中是否出现，出现的话就需要修改start指针的值为出现位置之后的位置，可以用哈希表降低复杂度进行优化。

**题解：**

```cpp
class Solution
{
public:
    int lengthOfLongestSubstring(string s)
    {
        int start = 0, end= 0, length = 0, result= 0;
        int sSize = int(s.size());
        while (end < sSize)
        {
            char tmpChar = s[end];
            for (int index = start; index < end; index++)
            {
                if (tmpChar == s[index])
                {
                    start = index + 1;
                    length = end - start;
                    break;
                }
            }
            end++;
            length++;
            result = max(result, length);
        }
        return result;
    }
};
```

```cpp
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        if(s.size() == 0) return 0;
        unordered_set<char> lookup;
        int maxStr = 0;
        int left = 0;
        for(int i = 0; i < s.size(); i++){
            while (lookup.find(s[i]) != lookup.end()){
                lookup.erase(s[left]);
                left ++;
            }
            maxStr = max(maxStr,i-left+1);
            lookup.insert(s[i]);
    }
        return maxStr;
    }
};
```

# 5. 最长回文子串 [medium]

给你一个字符串 `s`，找到 `s` 中最长的回文子串。

**示例 1：**

```
输入：s = "babad"
输出："bab"
解释："aba" 同样是符合题意的答案
```

**示例 2：**

```
输入：s = "cbbd"
输出："bb"
```

**提示：**

- `1 <= s.length <= 1000`
- `s` 仅由数字和英文字母组成

**思路：**

找到中心点向两边扩散，分奇数情况和偶数情况

**题解：**

``` cpp
class Solution {
public:
    string longestPalindrome(string s) {
        string res;
        for(int i = 0; i < s.size(); i ++) {
            int l = i - 1, r = i + 1; //回文子串是奇数，中心点前后l和r
            while(l >= 0 && r < s.size() && s[l] == s[r]) {
                l --;
                r ++;
            }
            if(res.size() < r - l - 1) {
                res = s.substr(l + 1, r - l - 1); //从l + 1开始 跨越 r - l - 1个字符
            }

            l = i, r = i + 1; //回文子串是偶数，i和i+1
            while(l >= 0 && r < s.size() && s[l] == s[r]) {
                l --;
                r ++;
            }
            if(res.size() < r - l - 1) {
                res = s.substr(l + 1, r - l - 1);
            }
        }
        return res;
    }
};
```

