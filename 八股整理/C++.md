# C++ 基础

## C++程序到可执行文件的过程

C++和c语言相似，一个C++程序从源码到执行文件，有四个过程：预编译，编译，汇编，链接

**预编译：**

1. 将所有的#define删除，并且展开所有的宏定义 
2. 处理条件预编译指令和#include指令，将被包含的文件插入到预编译指令的 
3. 过滤所有的注释 
4. 添加行号和文件名标识 

**编译：**

1. 词法分析：将源代码的字符序列分割成一系列记号 
2. 语法分析：对记号进行语法分析，产生语法树 
3. 语义分析：判断表达式是够有意义 
4. 代码优化 
5. 目标代码生成：生成汇编代码 
6. 目标代码优化 

**汇编：**

将汇编代码转变为机器可以执行的指令

**链接：**

将不同的源文件产生的目标文件进行链接，从而实现一个可以执行的程序

链接可以分为动态链接和静态链接：

## 动态链接和静态链接有什么区别

静态链接：

在链接的时候就已经把要调用的函数或者过程链接到了生成的可执行文件中，就算你去把静态库删除也不会影响可执行文件的执行。生成的静态链接库，Windows 下以 .lib 为后缀，Linux 下以 .a 为后缀。

动态链接：

在链接到时候没有把调用的函数链接进去，而是在执行过程中，再去找要链接的函数，生成的可执行文件中没有函数代码，只包含函数的重定位信息，所以当你删除动态库时，可执行文件就不能运行。生成的动态链接库，Windows 下以 .dll 为后缀，Linux 下以 .so 为后缀。

静态链接占用内存大，但是运行速度较快，效率高

动态链接占用内存较小，但是运行速度没有静态链接块。

## 深浅拷贝的区别

在未定义显示拷贝构造函数的情况下，系统会调用默认的拷贝函数——即浅拷贝，它能够完成成员的一一复制。当数据成员中没有指针时，浅拷贝是可行的；但当数据成员中有指针时，如果采用简单的浅拷贝，则两类中的两个指针将指向同一个地址，当对象快结束时，会调用两次析构函数，而导致指针悬挂现象，此时必须采用深拷贝。

深拷贝和浅拷贝的区别就在于深拷贝会在堆内存中申请另外的空间来存储数据，解决了指针悬挂的问题。当数据成员中包含指针时，就必须要使用深拷贝。

## C++ 三大特性

**封装**

把客观事物抽象为类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏，C++ 中将公共的数据或方法使用 public 修饰，而不希望被访问的数据或方法采用 private 修饰。

**继承**

类的派生指的是从已有类产生新类的过程。原有的类成为基类或父类，产生的新类称为派生类或子类，子类继承基类后，可以创建子类对象来调用基类的函数，变量等。

继承有三种方式：

**多态**

使用同一个接口但效果不同（重载实现编译时多态，虚函数实现运行时多态）

多态有两种形式的多态，一种是静态多态，一种是动态多态。

静态多态。静态多态的设计思想：对于相关的对象类型，直接实现它们各自的定义，不需要共有基类，甚至可以没有任何关系。只需要各个具体类的实现中要求相同的接口声明，静态多态本质上就是模板的具现化。

动态多态。对于相关的对象类型，确定它们之间的一个共同功能集，然后在基类中，把这些共同的功能声明为多个公共的虚函数接口。各个子类重写这些虚函数，以完成具体的功能。具体实现就是 C++ 的虚函数。

如何实现多态：

1. 重载。函数重载和运算符重载，编译期。

2. 虚函数。子类的多态性，运行期。

    在继承关系中，对于父类的方法我们也同样使用。但是正常来说，我们希望方法的行为取决于调用方法的对象，而不是指针或引用指向的对象有关。

3. 模板，类模板，函数模板。编译期

## 虚函数

当⼀个类中包含虚函数时，编译器会为该类⽣成⼀个虚函数表，保存该类中虚函数的地址，同样，派⽣类继承基类，派⽣类中⾃然⼀定有虚函数，所以编译器也会为派⽣类⽣成⾃⼰的虚函数表。当我们定义⼀个派⽣类对象时，编译器检测该类型有虚函数，所以为这个派⽣类对象⽣成⼀个虚函数指针，指向该类型的虚函数表，这个虚函数指针的初始化是在构造函数中完成的。

如果有⼀个基类类型的指针，指向派⽣类，那么当调⽤虚函数时，就会根据所指真正对象的虚函数表指针去寻找虚函数的地址，也就可以调⽤派⽣类的虚函数表中的虚函数以此实现多态。

**虚函数表原理**

C++实现虚函数的方法是：为每个类对象添加一个隐藏成员，隐藏成员保存了一个指针，这个指针叫**虚表指针**（vptr），它指向一个**虚函数表**（virtual function table, vtbl）

**虚函数表**就像一个数组，表中有许多的**槽（slot）**，每个槽中存放的是一个虚函数的地址（可以理解为数组里存放着指向每个虚函数的指针）

同一个类的所有[虚函数](https://www.zhihu.com/search?q=虚函数&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A1494631092})地址放到一个指针的数组里，每一个类一个表。另外在每一个对象的结构体中放置一个指向虚表的指针。在调用时，根据对象里的[虚表指针](https://www.zhihu.com/search?q=虚表指针&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A1494631092})找到对应的虚表，再根据调用函数确定虚表中的哪一个函数地址。在构造时，构造函数开头隐藏了一句把虚表指针指向本类的对应的虚表地址。由于构造顺序一定是先构造父类再构造子类，因此虚表指针在构造父类的时候被指像父类虚表，在构造子类的时候会再被覆盖成指向子类的虚表。因此即使是父类的指针，在调用时找到的也是子类的虚表，子类的函数。

**每个类使用一个虚函数表，每个类对象用一个虚表指针**

**创建时机**

虚函数表创建时机是在编译期间，编译期间编译器就为每个类确定好了对应的虚函数表里的内容，在程序运行时，编译器会把虚函数表的首地址赋值给虚函数表指针，所以，这个虚函数表指针就有值了。

vptr 跟着对象走，所以对象什么时候创建出来，vptr 就什么时候创建出来，也就是运行的时候。

**编译器如何处理虚函数表**

对于派生类来说：

- 拷贝基类的虚函数表，如果是多继承，就拷贝每个基类的虚函数表
- 查看派生类中是否有重写基类的虚函数，如果有，就替换成已经重写后的虚函数地址
- 查看派生类中是否有新添加的虚函数，如果有，就加入到自身的虚函数表中

### **虚析构函数**

如果类是父类，则必须声明为虚析构函数。基类声明一个虚析构函数，为了确保释放派生对象时，按照正确的顺序调用析构函数。

如果父类的析构函数不是虚函数，则不会触发动态绑定（多态），结果就是只会调用父类的析构函数，而不会调用子类的析构函数，从而**可能**导致子类的内存泄漏（如果子类析构函数中存在 free delete 等释放内存操作时）；

如果父类的析构函数是虚函数，则子类的析构函数一定是虚函数（即使是子类的析构函数不加 virtual），则会在父类指针或引用指向一个子类时，触发动态绑定（多态），析构实例化对象时，若是子类则会执行子类的析构函数，同时，编译器会在子类的析构函数中插入父类的析构函数，最终实现了先调用子类析构函数再调用父类析构函数。

### **构造函数能否是虚函数**

不能，虚函数通过虚函数表进行调用，类的每个对象中含有一个指向虚函数表的指针，这一指针在构造过程中被初始化，因此当对象没有被构造之前不能调用虚函数。如果构造函数是虚函数，也就没有办法调用构造函数了；虚函数作用是通过基类的指针或引用调用虚函数时发生动态绑定，但是构造函数是在创建对象时自动执行，不可能通过基类的指针或引用去调用，因此构造函数没有必要被定义为虚函数。

### **静态成员函数能否为虚函数？**

静态成员函数不能是虚函数，静态成员函数与类相关联，而不是与类的对象相关联。静态成员函数不含有this指针，也就无法得到虚表指针，也就无法通过虚函数表调用虚函数。

## 指针和引用的区别

- 指针是一个变量，存储的是一个地址，引用跟原来的变量实质上是同一个东西，是原变量的别名；
- 指针可以为空，引用不能为 NULL 且在定义时必须初始化；
- 指针在初始化后可以改变指向，而引用在初始化之后不可再改变；
- sizeof 指针得到的是本指针的大小，sizeo f引用得到的是引用所指向变量的大小；
- 当把指针作为参数进行传递时，也是将实参的一个拷贝传递给形参，两者指向的地址相同，但不是同一个变量，在函数中改变这个变量的指向不影响实参，而引用却可以。
- 在 C++ 中，指针和引用经常用于函数的参数传递，然而，指针传递参数和引用传递参数是有本质上的不同的：**指针传递**参数本质上是**值传递**的方式，它所传递的是一个地址值。值传递的特点是被调函数对形式参数的任何操作都是作为局部变量进行，不会影响主调函数的实参变量的值。而在**引用传递**过程中， 被调函数的形参虽然也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址（指针放的是实参变量地址的副本）。

## const 关键字

1. const 修饰变量：限定变量为不可修改。

2. const 修饰指针：指针常量和指向常量的指针

3. const 和函数：有以下几种形式

    `const int& fun(int& a); //修饰返回值
    int& fun(const int& a); //修饰形参
    int& fun(int& a) const{} //const成员函数`

4. const 和类：

    - const 修饰成员变量：在某个对象的声明周期内是常量，但是对于整个类而言是可以改变的。因为类可以创建多个对象，不同的对象其 const 成员变量的值是不同的。切记，不能再类内初始化 const 成员变量，因为类的对象没创建前，编译器并不知道 const 成员变量是什么，因此 const 数据成员只能在初始化列表中初始化。
    - const 修饰成员函数：主要目的是防止成员函数修改成员变量的值，即该成员函数并不能修改成员变量。
    - const 对象：常对象，常对象只能调用常函数。

5. 限定成员函数不可以修改任何数据成员

## static 关键字

static 修饰的普通变量初始化在 main 函数执行前

修饰变量：

- 局部变量

    - 局部变量被定义为局部静态变量；
    - 内存中的位置：静态存储区；
    - 初始化：局部的静态变量只能被初始化一次；
    - 作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域随之结束。

    static 修饰局部变量时，改变了局部变量存储的位置和生命周期（离开作用域后没有被销毁，但不能访问，直到程序结束），但作用域不改变 。

- 全局变量

    - 在全局变量之前加上关键字 static，全局变量就被定义成为一个全局静态变量。
    - 内存中的位置：静态存储区；
    - 初始化：未经初始化的全局静态变量会自动初始化为0；
    - 作用域：本文件中。

    区别全局变量和静态全局变量：

    全局变量本身就是静态存储方式，静态全局变量当然也是静态存储方式。两者的区别在于非静态全局变量的作用域是整个源程序， 当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的（在其他源文件中使用时加上 extern 关键字重新声明即可）。 而**静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效， 在同一源程序的其它源文件中不能使用它**。

修饰函数：

修饰普通函数，表明函数的作用范围，仅在定义该函数的文件内才能使用。（和全局变量一样限制了作用域）

修饰类：

- 成员变量

    用 static 修饰类的数据成员实际使其成为类的全局变量，会被类的所有对象共享，**包括派生类的对象**。

    因此，static 成员必须在类外进行初始化，而不能在构造函数内进行初始化。不过也可以用 const 修饰 static 数据成员在类内初始化 。

- 成员函数

    用 static 修饰成员函数，使这个类只存在这一份函数，所有对象共享该函数，不含 this 指针。

    静态成员是可以独立访问的，也就是说，无须创建任何对象实例就可以访问。

    **不可以同时用 const 和 static 修饰成员函数。**
    
    - C++ 编译器在实现 const 的成员函数的时候为了确保该函数不能修改类的实例的状态，会在函数中添加一个隐式的参数 const this*。但当一个成员为 static 的时候，该函数是没有 this 指针的。也就是说此时 const的用法和 static 是冲突的。两者的语意是矛盾的。**static 的作用是表示该函数只作用在类型的静态变量上，与类的实例没有关系；而 const 的作用是确保函数不能修改类的实例的状态**，与类型的静态变量没有关系。因此不能同时用它们。

## C++ 内存布局/程序分段

也可以叫做进程逻辑地址空间

内存从上到下分别是：

- 栈 stack |高地址|
- 堆 heap
- bss 段（全局/静态存储区）
- data 段（常量存储区）
- 代码段 text |低地址|

栈：保存函数的局部变量，参数以及返回值。在函数调用后，系统会清楚栈上保存的栈帧和局部变量，函数参数等信息。栈是从高到低增长的。

堆：动态内存分配的都放在堆上，需要手动进行分配和回收，可能会出现内存泄漏和空闲碎片的情况。堆是从低到高的。

bss 段：（Block Started by Symbol）存放程序中未初始化的全局变量的一块内存区域，在程序载入时由内核置为0，存储初始化和未初始化的全局变量和静态变量。

data 段：static 变量和所有初始化的全局变量都在 data 段中。

> bss 段和 data 段都是静态内存分配，也就是说在编译的时候自动分配的。
>
> bss 和 data 段也有一种说法合起来叫数据段，有三种类型：
>
> 1. 只读数据段，常量与 const 修饰的全局变量
> 2. 可读可写数据段，存放初始化的全局变量和 static 变量
> 3. bss 段，存放未初始化的全局变量

text 段：代码段，text 段在内存中被映射为只读，但 .data 和 .bss 是可写的。由编译器在编译连接时自动计算的，当你在链接定位文件中将该符号放置在代码段后，那么该符号表示的值就是代码段大小，编译连接时，该符号所代表的值会自动代入到源程序中。

## 堆和栈区别，哪个分配快

- 申请方式不同：
    - 堆是由程序员管理，需要手动进行分配和回收
    - 栈由编译器自动分配空间
- 申请大小限制：
    - 堆向高地址扩展，是不连续的内存区域，大小可以灵活调整
    - 栈是高地址向低地址扩展，栈底高地址，空间小
- 内存管理机制：
    - 堆：系统有一个记录空闲内存地址的链表，当系统收到程序申请时，遍历该链表，寻找第一个空间大于申请空间的堆结点，删除空闲结点链表中的该结点，并将该结点空间分配给程序（大多数系统会在这块内存空间首地址记录本次分配的大小，这样 delete 才能正确释放本内存空间，另外系统会将多余的部分重新放入空闲链表中）
    - 栈：只要栈的剩余空间大于所申请空间，系统为程序提供内存，否则报异常提示栈溢出。
- 申请效率：
    - 堆由程序员分配，速度慢，有碎片
    - 栈由系统分配，速度快，不会有碎片

## new / delete 与 malloc / free 

**区别：**

- 前者是 C++ 运算符，后者是 C/C++ 语言标准库函数
- new 自动计算要分配的空间大小，malloc 需要手工计算
- new 是类型安全的，malloc 不是
- new 调用名为 **operator new** 的标准库函数分配足够空间并调用相关对象的构造函数，delete 对指针所指对象运行适当的析构函数；然后通过调用名为 **operator delete** 的标准库函数释放该对象所用内存。后者均没有相关调用
- 后者需要库文件支持，前者不用
- new 是封装了 malloc，直接 free 不会报错，但是这只是释放内存，而不会析构对象

**调用 new 操作符分配对象**

1. 调用 operator new 函数分配一块足够大的，原始的空间；
2. 编译器运行相应的构造函数以构造对象，并传入初值；
3. 构造完对象后，就返回一个指向该对象的指针。

**为什么要 new / delete**

在对非基本数据类型的对象使用的时候，对象创建的时候还需要执行构造函数，销毁的时候要执行析构函数。而 malloc/free 是库函数，是已经编译的代码，所以不能把构造函数和析构函数的功能强加给 malloc/free ，所以 new/delete 是必不可少的。

## new、operator new 和 placement new

### **new/delete 与 operator new/operator delete**

new operator/delete operator 就是 `new` 和 `delete` 操作符，而 `operator new/operator delete` 是函数。

new operator

- 调用operator new分配足够的空间，并调用相关对象的构造函数
- 不可以被重载

operator new

- 只分配所要求的空间，不调用相关对象的构造函数。

    当无法满足所要求分配的空间时，如果有 new_handler，则调用 new_handler，否则如果没要求不抛出异常（以 nothrow 参数表达），则执行bad_alloc 异常，否则返回0。

- 可以被重载

- 重载时，返回类型必须声明为void*

- 重载时，第一个参数类型必须为表达要求分配空间的大小（字节），类型为size_t

- 重载时，可以带其它参数

`operator new` 与 `operator delete` 和C语言中的 `malloc` 与 `free` 对应，只负责分配及释放空间。但使用 `operator new` 分配的空间必须使用 `operator delete` 来释放，而不能使用 `free`，因为它们对内存使用的登记方式不同。反过来亦是一样。你可以重载 `operator new` 和 `operator delete` 以实现对内存管理的不同要求，但你不能重载 new operator 或 delete operator 以改变它们的行为。

### placement new

`placement new` 是重载 `operator new` 的一个标准，全局的版本，不能够被自定义的版本代替。它并不分配内存，只是返回指向已经分配好的某段内存的一个指针，因此不能删除它，但需要调用对象的析构函数。

```c++
void *operator new( size_t, void * p ) throw() { return p; }
```

`placement new` 的执行忽略了 `size_t` 参数，只返还第二个参数，其结果是允许用户把一个对象放到一个特定的地方，达到调用构造函数的效果。和其他普通的 `new` 不同的是，它在括号里多了另外一个参数：

```cpp
Widget *p = new Widget; // ordinary new
pi = new(ptr)int; // placement new
```

括号里的参数 `ptr` 是一个指针，它指向一个内存缓冲器，`placement new` 将在这个缓冲器上分配一个对象。

`placement new` 的返回值是这个被构造对象的地址(比如括号中的传递参数)。`placement new` 主要适用于：在对时间要求非常高的应用程序中，因为这些程序分配的时间是确定的；长时间运行而不被打断的程序；以及执行一个垃圾收集器 (garbage collector)。

## `final` 和 `override`

当在父类中使用了虚函数时候，你可能需要在某个子类中对这个虚函数进行重写，以下方法都可以：

```cpp
class A {
 virtual void foo();
}
class B : public A {
 void foo(); //OK
 virtual void foo(); // OK
 void foo() override; //OK
}
```

使用 `override`关键字指定了子类的这个虚函数是重写的父类的，如果你名字不小心打错了的话，编译器是不会编译通过的。

**final**

当不希望某个类被继承，或不希望某个虚函数被重写，可以在类名和虚函数后添加 final 关键字，添加 final 关键字后被继承或重写，编译器会报错。

## C++ 构造函数

类对象被创建时，编译器为对象分配内存空间，并自动调用构造函数，由构造函数完成成员的初始化工作。

因此构造函数的的作用是初始化对象的成员函数。

- **默认构造函数：**如果没有人为构造函数，则编译器会自动默认生成一个无参构造函数。

- **一般构造函数：**包含各种参数，一个类可以有多个一般构造函数，前提是参数的个数和类型和传入参数的顺序都不相同，根据传入参数调用对应的构造函数。

- **拷贝构造函数：**拷⻉构造函数的函数参数为对象本身的引用，用于根据⼀个已存在的对象复制出⼀个新的该类的对象，⼀般在函数中会将已存在的对象的数据成员的值⼀⼀复制到新创建的对象中。如果没有显示的写拷⻉构造函数，则系统会默认创建⼀个拷⻉构造函数，但当类中有指针成员时，最好不要使⽤编译器提供的默认的拷⻉构造函 数，最好⾃⼰定义并且在函数中执⾏深拷⻉。

- **移动构造函数：**有时候我们会遇到这样一种情况，我们用对象 a 初始化对象 b 后对象 a 我们就不在使用了，但是对象 a 的空间还在呀（在析构之前），既然拷贝构造函数，实际上就是把 a 对象的内容复制一份到 b 中，那么为什么我们不能直接使用 a 的空间呢？这样就避免了新的空间的分配，大大降低了构造的成本。这就是移动构造函数设计的初衷。拷贝构造函数中，对于指针，我们一定要采用深层复制，而移动构造函数中，对于指针，我们采用浅层复制。

    但是指针的浅层复制是非常危险的。浅层复制之所以危险，是因为两个指针共同指向一片内存空间，若第一个指针将其释放，另一个指针的指向就不合法了（pointer dangling）。所以我们只要避免第一个指针释放空间就可以了。避免的方法就是将第一个指针（比如a->value）置为NULL，这样在调用析构函数的时候，由于有判断是否为NULL的语句，所以析构a的时候并不会回收a->value指向的空间（同时也是b->value指向的空间）

- **赋值构造函数：**=运算符的重载，类似拷贝构造函数，将 = 右边的类对象赋值给类对象左边的对象，不属于构造函数，=两边的对象必须都要被创建。

- **类型转换构造函数：**有时候不想要隐式转换，用explict关键字修饰。

## 左值和右值

左值：**可以取地址、位于赋值符号左边**的值，左值是表达式结束（不一定是赋值表达式）后依然存在的对象。

右值：可以提供数据值的表达式（不一定可以寻址，例如存储于寄存器中的数据）。如：

1. 字面值(字符串字面值除外)，例如1，'a', true等
2. 返回值为非引用的函数调用或操作符重载，例如：str.substr(1, 2), str1 + str2, or it++
3. 后置自增和自减表达式(a++, a--)
4. 算术表达式（x + y;）
5. 逻辑表达式
6. 比较表达式
7. 取地址表达式
8. lambda表达式`auto f = []{return 5;};`

右值又有纯右值和将亡值的说法。非引用返回的临时变量、运算表达式产生的临时变量、原始字面量和 lambda 表达式等都是纯右值。而将亡值是与右值引用相关的表达式，比如，将要被移动的对象、T&& 函数返回值、std::move 返回值和转换为 T&& 的类型的转换函数的返回值等。

## 左值引用和右值引用

右值引用是 C++11 中新增加的一个很重要的特性，他主是要用来解决 C++98/03 中遇到的两个问题

- 第一个问题就是临时对象非必要的昂贵的拷贝操作
- 第二个问题是在模板函数中如何按照参数的实际类型进行转发。

要拿到一个将亡值，就需要用到右值引用：`T &&`。右值引用的声明让这个临时值的生命周期得以延长、只要变量还活着，那么将亡值将继续存活。C++11 提供了 `std::move` 这个方法将左值参数无条件的转换为右值，有了它我们就能够方便的获得一个右值临时对象。

**移动语义**

右值引用的一个重要作用是用来支持移动语义的。那我们知道了移动语义是通过右值来匹配临时值的，那么很自然会想到，普通的左值是否也能借助移动语义来优化性能呢？C++11为了解决这个问题，提供了 std::move 方法来将左值转换为右值，从而方便应用移动语义。move 是将对象资源的所有权从一个对象转移到另一个对象，只是转移，没有内存的拷贝，这就是所谓的 move 语义。

move 实际上它并不能移动任何东西，它唯一的功能是将一个左值强制转换为一个右值引用。如果是一些基本类型比如 int 和 char[10] 定长数组等类型，使用 move 的话仍然会发生拷贝（因为没有对应的移动构造函数）。所以，move 对于含资源（堆内存或句柄）的对象来说更有意义。

**完美转发**

在函数模板中，完全依照模板的参数的类型（即保持参数的左值、右值特征），将参数传递给函数模板中调用的另外一个函数。C++11 中的 std::forward 正是做这个事情的，他会按照参数的实际类型进行转发。

## C++ 类型转换

1. **static_cast**：用于基本数据类型之间的转换，如：void*和其他类型指针之间的转换、子类对象的指针转换成父类对象指针。

    最好把所有**隐式转换**都用 static_cast 代替

2. **const_cast**：用来移除变量的 const 特性，但是不能用于去除变量的常量性，而是去除指向对象的引用或指针的常量性，因此去除对象必须是指针或者引用。

    - 指向常量的指针被转化成非常量指针，并且仍然指向原来的对象；

    - 常量引用被转换成非常量引用，并且仍然指向原来的对象；

    - 常量对象被转换成非常量对象。

3. **dynamic_cast**：不能用于内置类型转换，主要是继承关系的子类和父类之间的转换，一般是downcasting，向下强制转换。

    子类指针指向父类指针，作用和 static_cast 一样，但将父类指针转化成子类指针，static_cast 可能会失败

    **转换成功会返回引用或者指针，失败返回null**

4. **reinterpret_cast**：将任意类型指针转换为其他类型的指针。

    改变指针或者引用的类型

    - 将指针或者引用转换成一个足够长度的整型

    - 将整型转换成指针或引用类型

## lambda 表达式

**lambda 表达式特点**

lambda 表达式定义了一个匿名函数，并且可以捕获一定范围内的变量。lambda 表达式的语法形式简单归纳如下：

```cpp
[capture](params) opt -> ret {body;};
```

其中 `capture` 是捕获列表，`params` 是参数列表，`opt` 是函数选项，`ret` 是返回值类型，`body` 是函数体。

## 智能指针

**为什么要使用智能指针？**

1. 防止内存泄漏：C++ 在堆上申请内存后，需要手动对内存进行释放。
2. 多线程下对象析构问题，造成这个问题本质的原因是类对象自己销毁(析构)的时候无法对自己加锁，所以要独立出来，采用这个中间层。

**shared_ptr**

共享所有权，也就是说多个指针可以指向一个相同的对象，当最后一个shared_ptr离开作用域的时候才会释放掉内存。

**实现原理：**
在 shared_ptr 内部有一个共享引用计数器来自动管理，计数器实际上就是指向该资源指针的个数，每当复制一个 shared_ptr，引用计数会 + 1。当一个 shared_ptr 离开作用域时，引用计数会 - 1，当引用计数为 0 的时候，则 delete 内存。当计数器为0的时候指针才会彻底释放掉这个资源。

**线程安全问题：**

shared_ptr 可能的线程安全隐患大概有如下几种，一是引用计数的加减操作是否线程安全，二是shared_ptr修改指向时，是否线程安全。

1. shared_ptr 的引用计数是原子操作的，所以引用计数的加减是线程安全的。
2. shared_ptr修改指针指向的时候会不安全。 同一个shared_ptr被多个线程“读”是安全的。同一个shared_ptr被多个线程“写”是不安全的(多个线程操作同一个shared_ptr对象)。

**weak_ptr**

它主要是为了配合 `shared_ptr` 而存在的。就像它的名字一样，它本身是一个弱指针，因为它本身是不能直接调用原生指针的方法的。如果想要使用原生指针的方法，需要将其先转换为一个 `shared_ptr`。

主要为了解决 `shared_ptr` 指针循环引用（a 对象持有 b 对象，b 对象持有 a 对象）造成的内存泄露问题，`weak_ptr` 不会增加引用计数，通过将循环引用中的一方修改为弱引用，可以避免内存泄漏。

**方法**

1. expired() 判断所指向的原生指针是否被释放，如果被释放了返回 true，否则返回 false
2. use_count() 返回原生指针的引用计数
3. lock() 返回 shared_ptr，如果原生指针没有被释放，则返回一个非空的 shared_ptr，否则返回一个空的 shared_ptr
4. reset() 将本身置空

**unique_ptr**

`unique_ptr `的核心特点就如它的名字一样，它拥有对持有对象的唯一所有权。即两个 `unique_ptr` 不能同时指向同一个对象，体现在：

1. `unique_ptr` 不能被复制到另外一个 `unique_ptr`
2. `unique_ptr` 所持有的对象只能通过转移语义将所有权转移到另外一个 `unique_ptr`

## std::function 和 std::bind

C++11 的 `std::function` 和 `std::bind` 作用的对象叫做可调用对象：

std::function是一个可调用对象包装器，是一个类模板，可以容纳除了类成员函数指针之外的所有可调用对象，它可以用统一的方式处理函数、函数对象、函数指针，lambda表达式并允许保存和延迟它们的执行，std::function对C++中各种可调用实体(普通函数、Lambda表达式、函数指针、以及其它函数对象等)的封装，形成一个新的可调用的std::function对象，简化调用。

std::bind可以看作一个通用的函数适配器，它接受一个可调用对象，生成一个新的可调用对象来适应原对象的参数列表。std::bind将可调用对象与其参数一起进行绑定，绑定后的结果可以使用std::function保存。std::bind主要有以下两个作用：

1. 将可调用对象和其参数绑定成一个仿函数；
2. 只绑定部分参数，减少可调用对象传入的参数。

## 原子操作

它表示在多个线程访问同一个全局资源的时候，能够确保所有其他的线程都不在同一时间内访问相同的资源。也就是他确保了在同一时刻只有唯一的线程对这个资源进行访问。这有点类似互斥对象对共享资源的访问的保护，但是原子操作更加接近底层，因而效率更高。

互斥对象的使用，保证了同一时刻只有唯一的一个线程对这个共享进行访问，从执行的结果来看，互斥对象保证了结果的正确性，但是也有非常大的性能损失。

# STL

**STL包含6大部件：容器、迭代器、算法、仿函数、适配器和空间配置器。**

- 容器：容纳一组元素的对象，提供各种数据结构。
- 迭代器：提供一种访问容器中每个元素的方法，从实现的角度来说，迭代器是一种将`operator*`, `operator->`, `operator++`等指针操作赋予 重载的类模板。
- 仿函数：一个行为类似函数的对象，调用它就像调用函数一样，重载了`operator()`的类或者类模板。
- 算法：包括查找算法、排序算法等等。
- 适配器：用来修饰容器等，比如queue和stack，底层借助了deque。
- 空间配置器：负责空间配置和管理，是一个实现了动态空间配置，空间管理，空间释放的类模板。

## 空间配置器

**为什么需要空间配置器**

我们知道动态开辟内存时，要在堆上申请，但若是我们需要频繁的在堆开辟释放内存，则就会**在堆上造成很多外部碎片**，浪费了内存空间；每次都要进行调用 **malloc、free** 函数等操作，使空间就会增加一些附加信息，降低了空间利用率；随着外部碎片增多，内存分配器在找不到合适内存情况下需要合并空闲块，浪费了时间，大大降低了效率。于是就设置了二级空间配置器，**当开辟内存<=128bytes时，即视为开辟小块内存，则调用二级空间配置器。**

**二级空间配置器**

1. 维护16条链表，分别是 0-15 号链表，最小 8 字节，以 8 字节逐渐递增，最大 128 字节，你传入一个字节参数，表示你需要多大的内存，会自动帮你校对到第几号链表（如需要13bytes空间，我们会给它分配16bytes大小），在找到第 n 个链表后查看链表是否为空，如果不为空直接从对应的 free_list 中拔出，将已经拨出的指针向后移动一位。

2. 对应的 free_list 为空，先看其内存池是不是空时，如果内存池不为空:

    （1）先检验它剩余空间是否够20个节点大小（即所需内存大小(提升后) * 20），若足够则直接从内存池中拿出20个节点大小空间，将其中一个分配给用户使用，另外19个当作自由链表中的区块挂在相应的 free_list 下，这样下次再有相同大小的内存需求时，可直接拨出。

    （2）如果不够20个节点大小，则看它是否能满足1个节点大小，如果够的话则直接拿出一个分配给用户，然后从剩余的空间中分配尽可能多的节点挂在相应的 free_list 中。

    （3）如果连一个节点内存都不能满足的话，则将内存池中剩余的空间挂在相应的 free_list 中（找到相应的 free_list），然后再给内存池申请内存。

3. 内存池为空，申请内存此时二级空间配置器会使用 malloc() 从 heap 上申请内存，（一次所申请的内存大小为2 * 所需节点内存大小（提升后）* 20 + 一段额外空间），申请40块，一半拿来用，一半放内存池中。

4. malloc 没有成功 在第三种情况下，如果 malloc() 失败了，说明 heap 上没有足够空间分配给我们了，这时，二级空间配置器会从比所需节点空间大的 free_list 中一一搜索，从比它所需节点空间大的 free_list 中拔除一个节点来使用。如果这也没找到，说明比其大的 free_list 中都没有自由区块了，那就要调用一级适配器了。

释放时调用 deallocate() 函数，若释放的 n>128，则调用一级空间配置器，否则就直接将内存块挂上自由链表的合适位置。

## vector

vector 是动态空间，随着元素的加入它内部机制会自行空充空间以容纳新元素。vector 维护了一个连续的线性空间，普通指针就可以满足要求作为 vector 的迭代器，随机访问迭代器。vector 里面其实有三个迭代器，分别是指向空间头部的 iterator，指向空间尾部的 iterator 和指向可用空间的 iterator。当有新的元素插入时，如果当前容量够就直接插入，如果容量不够则扩容至两倍或1.5倍，如果两倍不足，则扩容至足够大的空间。由于扩充过程不是在原有的空间后面追加，而是重新申请一块新的连续内存，所以所有迭代器都会失效。

### reverse 和 resize 的区别

vector 的 reserve 增加了 vector 的 capacity，但是它的 size 没有改变

resize 改变了 vector 的 capacity 同时也增加了它的 size，原因如下：

1. reserve 是容器预留空间，但在空间内不真正创建元素对象，所以在没有添加新的对象之前，不能引用容器内的元素。加入新的元素时，要调用 push_back()/insert() 函数。
2. resize 是改变容器的大小，且在创建对象，因此，调用这个函数之后，就可以引用容器内的对象了，因此当加入新的元素时，用 operator[] 操作符，或者用迭代器来引用元素对象。此时再**调用 push_back() 函数，是加在这个新的空间后面的。**

### vector 支持越界检查吗

通过 operator[] 获取数组元素，不会检查下标有效性，需要检查的时候使用 at 接口

### push_back 和 emplace_back 区别

**使用 push_back() 函数需要调用拷贝构造函数和转移构造函数，而使用 emplace_back() 插入的元素原地构造，不需要触发拷贝构造和转移构造**，效率更高。

### 如何释放空间

vector 的内存占用空间只增不减，比如你首先分配了10,000个字节，然后 erase 掉后面9,999个，留下一个有效元素，但是内存占用仍为10,000个。

**所有的内存空间是在 vector 析构时候才能被系统回收。**

empty() 用来检测容器是否为空的，clear() 可以清空所有元素。但是即使 clear()，vector 所占用的内存空间依然如故，无法保证内存的回收。vector，可以用 swap() 来帮助你释放内存。

```c++
vector().swap(Vec); //清空Vec的内存；
```

## deque

vector 是单向开口的连续线性空间，deque 是一种双向开口的连续线性空间。双向开口就是说 deque 支持从头尾两端进行元素的插入和删除操作。deque没有容量的概念，因为它是动态以分段连续空间组合而成，随时可以增加一段新的空间并连接起来。由于要维护这种整体连续的假象，并提供随机存取的接口。

## map 和 unordered_map

map 底层数据结构：红黑树，有序，不重复

unordered_map 底层数据结构：hash table，无序

**map 缺点**

- 占用的空间大：红黑树的每一个节点需要保存其父节点位置、孩子节点位置及红/黑性质，因此每一个节点占用空间大。
- 查询平均时间不如unordered_map。

**unordered_map 使用什么方法解决 hash 冲突**

拉链法

开放寻址法

## 迭代器失效

### 删除元素

- 删除元素后，指向被删除元素的迭代器、指针和引用会失效（这应该不会令人惊讶。毕竟这些元素已经被销毁了）；
- 删除 deque 中除首尾位置之外的任何元素都会使迭代器、引用和指针失效；
- 指向 vector 或 string 中删除点之后位置的迭代器、引用和指针都会失效；（deque 和 vector 的删除操作会返回一个指向被删元素之后元素的迭代器）
- 对于list和forward_list，指向容器的迭代器、指针和引用仍有效。
- 对于关联容器：指向被删除元素的迭代器、引用和指针会失效

注：`data.map(iter)` 之后，`iter` 已经失效了，所以 `iter` 无法自增，即 `iter++` 就会出 bug。

解决方案，就是在 `iter` 失效之前，先自增。

```c++
1. datamap.erase(iter++);
2.  auto tmpIter = iter; 
	++iter;
	dataMap.erase(tmpIter);
```

### 插入元素

如果容器是 vector 或 string，且存储空间被重新分配，则指向容器的迭代器、指针和引用都会失效。如果存储空间未重新分配，指向插入位置之前的元素的迭代器、指针和引用仍有效，但指向插入位置之后元素的迭代器、指针和引用将会失效。

对于 deque，插入除首尾位置之外的任何位置都会导致迭代器、指针和引用失效。如果在首尾位置添加元素，迭代器会失效，但指向存在的元素的引用和指针不会失效。

## 容器使用场景

### 顺序容器

- 除非有更好的理由选择其他容器，否则应使用 vector。

- 如果程序要求随机访问，应使用 vector 或 deque。

- 如果要求在容器的中间插入或删除元素，应使用 list 或 forward_list。

- 如果程序需要在头尾插入或删除元素，但不会在中间位置进行插入或删除操作，则使用 deque。

- 如果程序只有在读取输入时才需要在容器中间位置插入元素，随后需要随机访问元素，则

    - 首先，确定是否真的需要在容器中间位置添加元素。当处理输入数据时，通常可以很容易地向 vector 追加数据，然后调用标准库的 sort 函数来重排容器中的元素，从而避免在中间位置添加元素。

    - 如果必须在中间位置插入元素，考虑在输入阶段使用 list，一旦输入完成，将 list 中的内容拷贝到一个 vector 中。

- 如果既需要随机访问，有需要再容器中间位置插入、删除元素，考虑随机的访问操作更多还是插入/删除操作更多。

- 当对象较大，或者构造函数复杂时，list 的性能要优于 vector。因为，在对现有元素进行拷贝时，开销较大。

### 关联容器

- map 是关键字值对的集合：关键字起到索引的作用，值则表示与索引相关联的数据。

- set 支持高效的关键字查询操作——检查一个给定的关键字是否在 set 中。