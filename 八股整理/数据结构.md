# 排序算法比较

![image-20220830100530764](数据结构.assets/image-20220830100530764-1825137.png)

## 快排

```cpp
void quick_sort(int q[], int l, int r) {
    if (l >= r) return;
    int i = l - 1, j = r + 1, x = q[(l+r)>>1];
    while (i < j) {
        do i++; while (q[i] < x);
        do j--; while (q[j] > x);
        if (i < j) swap(q[i], q[j]);
    }
    quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```

## 归并排序

```cpp
void merge_sort(int l, int r) {
    if (l >= r) return;
    // 确定分界点
    int mid = (l + r) / 2;
    // 递归处理
    merge_sort(l, mid), merge_sort(mid + 1, r);
    // 归并的过程，合二为一的过程
    int k = 0, i = l, j = mid + 1;
    while (i <= mid && j <= r) {
        if (q[i] <= q[j]) temp[k++] = q[i++];
        else temp[k++] = q[j++];
    }
    while (i <= mid) temp[k++] = q[i++];
    while (j <= r) temp[k++] = q[j++];
    // 搬回q[]
    for (i = l, k = 0; i <= r; i++, k++) q[i] = temp[k];
}
```

# LRU

```cpp
class LRUCache {
public:
    LRUCache(int capacity) : cap(capacity) { }  // 列表初始化
    int get(int key) {
        if (map.find(key) == map.end()) return -1;
        auto key_value = *map[key];
        cache.erase(map[key]);
        cache.push_front(key_value);
        map[key] = cache.begin();
        return key_value.second;
    }
    void put(int key, int value) {
        if (map.find(key) == map.end()) {
            if (cache.size() == cap) {
                map.erase(cache.back().first);
                cache.pop_back();
            }
        }
        else {
            cache.erase(map[key]);
        }
        cache.push_front({key, value});
        map[key] = cache.begin();
    }
private:
    int cap;
    list<pair<int, int>> cache; // 双向链表
    unordered_map<int, list<pair<int, int>>::iterator> map; //直接使用迭代器作为map的value
};
```

# 反转链表

迭代：

```c++
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode *dummy = new ListNode(-1);
        ListNode *cur = head;
        while (cur != nullptr) {
            ListNode *temp = cur->next;
            cur->next = dummy->next;
            dummy->next = cur;
            cur = temp;
        }
        return dummy->next;
    }
};
```

递归：

```c++
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if (head == nullptr || head->next == nullptr) {
            return head;
        }
        ListNode* ret = reverseList(head->next);
        head->next->next = head;
        head->next = nullptr;
        return ret;
    }
};。
```

