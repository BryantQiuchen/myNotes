# 第一章 OS概述

<img src="/Users/ryan/Documents/notes/images/os/截屏2022-02-18 下午2.17.19.png" alt="截屏2022-02-18 下午2.17.19" style="zoom:50%;" />

## 1.1 OS的基本概念

### OS的功能和目标

- 系统资源的管理者
    - 提供功能：
        - 处理机管理
        - 存储器管理
        - 文件管理
        - 设备管理
    - 目标：安全，高效
- 作为用户和计算机硬件之间的接口
    - 命令接口：允许用户使用（联机命令：交互式命令接口（cmd）、脱机命令接口：批处理命令接口）
    - 程序接口：允许用户通过程序间接使用（.dll文件，系统调用）
    - GUI（Graphical User Interface）：现代操作系统中最流行的图形用户接口
    - 目标：方便用户使用
- 作为最接近硬件的层次
    - 实现对硬件机器的拓展

### OS特征

- 并发
    - 两个或多个事件在同一时间间隔内发生，宏观上同时发生，微观上交替发生
    - 区别并行：两个或多个事件同一时刻同时发生
    - ==操作系统的并发性==指计算机系统中同时存在多个运行的程序（单CPU下同一时刻只能执行一个程序，多个程序交替进行）
- 共享
    - 资源共享，指系统中资源可供内存中多个并发执行的进程共同使用
        - 互斥共享方式：某些资源一个时间段内只允许一个进程访问该资源， 如摄像头资源、打印
        - 同时共享粉饰：这类资源允许在一个时间内由多个进程“同时”访问（宏观上同时，微观上交替进行，分时共享），如qq和微信都发送文件
- 并发和共享是OS两个最基本特征，互为存在条件：
    - 资源共享是以程序并发为条件，若不允许程序并发执行，则不存在资源共享
    - 若系统不能对资源共享实施有效管理，会影响到并发执行
- 虚拟
    - 虚拟是指把一个物理上的实体变为若干逻辑上的对应物。物理实体(前者)是实际存在的；而逻辑上（后者）是用户感觉上的事物。
    - 空分复用技术（虚拟存储器技术），时分复用技术（分时共享）
- 异步
    - 多道程序环境允许多个程序并发执行，但由于资源有限，进程的执行并不是一贯到底的，而是走走停停的，它以不可预知的速度向前推进，这就是进程的异步性

### OS发展和分类

<img src="/Users/ryan/Documents/notes/images/os/截屏2022-01-05 下午3.35.05.png" alt="截屏2022-01-05 下午3.35.05" style="zoom:75%;" />

## 1.2 OS的运行环境

### 1.2.1 运行机制

两种指令

- 特权指令：如内存清零指令；（不允许用户程序使用）
- 非特权指令：如普通运算指令。

两种处理器状态（用程序状态字寄存器PSW）

- 用户态（目态）：只能执行非特权指令；
- 核心态（管态）：可以执行特权和非特权指令。

两种程序

- 内核程序（核心态）
- 应用程序（用户态）

OS内核

![截屏2022-01-11 下午8.56.36](/Users/ryan/Documents/notes/images/os/截屏2022-01-11 下午8.56.36.png)

### 1.2.2 中断和异常

#### 定义

中断（Interruption）称外中断，指来自CPU执行指令以外的事件发生；当中断发生，CPU进入核心态；发生中断意味着需要OS介入管理；有了中断，才能实现多道程序并发执行。

异常（Exception）称内中断，指源自CPU执行指令内部的事件。

<img src="/Users/ryan/Documents/notes/images/os/截屏2022-01-11 下午9.05.21.png" alt="截屏2022-01-11 下午9.05.21" style="zoom:50%;" />

#### 外中断处理过程

<img src="/Users/ryan/Documents/notes/images/os/截屏2022-01-11 下午9.17.38.png" alt="截屏2022-01-11 下午9.17.38" style="zoom:50%;" />

### 1.2.3 系统调用

指用户在程序中调用操作系统所提供的一些子功能（打印中，一起请求，顺序进行不会同时进行）

按功能分类（核心态下才能进行）：

- 设备管理
- 文件管理
- 进程控制
- 进程通信
- 内存管理

#### 系统调用和库函数区别

<img src="/Users/ryan/Documents/notes/images/os/截屏2022-01-16 下午7.04.08.png" alt="截屏2022-01-16 下午7.04.08" style="zoom:50%;" />

#### 系统调用的过程

![截屏2022-01-16 下午7.31.52](/Users/ryan/Documents/notes/images/os/截屏2022-01-16 下午7.31.52.png)

- 发出系统调用请求是在用户态，对系统调用作相应处理是在核心态下进行；
- 陷入指令是唯一一个只能在用户态执行，不能在核心态执行的指令

# 第二章 进程管理

<img src="/Users/ryan/Documents/notes/images/os/截屏2022-02-18 下午2.18.35.png" alt="截屏2022-02-18 下午2.18.35" style="zoom:50%;" />

 ## 2.1 进程与线程

### 2.1.1 进程的定义

进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。

程序段（程序代码）、数据段（程序运行使用的运算数据）、PCB（PCB中包含操作系统对其进行管理所需的各种信息）三部分组成了进程实体（进程印象）。所谓创建进程，实质是创建进程实体中的PCB；撤销进程，实质上是撤销进程实体中的PCB（==PCB是进程存在的唯一标志==）

### 2.1.2 进程的组织

进程的组成讨论的是一个进程内部由什么部分构成，进程的组织讨论的是多个进程之间的组织方式问题

<img src="/Users/ryan/Documents/notes/images/os/截屏2022-01-18 上午10.39.10.png" alt="截屏2022-01-18 上午10.39.10" style="zoom:30%;" />

### 2.1.3 进程的状态和转换

三种基本状态

- 运行态（Running）：占有CPU（单核处理机每时刻只能有一个进程处于运行态）
- 就绪态（Ready）：已具备运行条件但由于没有空闲CPU而暂时不能运行
- 阻塞态/等待态（Blocked/Waiting）：等待某一件事而暂时不能运行

其他两个状态

- 创建态（New）：进程正在被创建，OS为进程分配资源、初始化PCB
- 结束态（Terminated）：进程正在从系统中撤销，OS会回收进程拥有的资源、撤销PCB

#### 状态转换

<img src="/Users/ryan/Documents/notes/images/os/截屏2022-01-18 上午10.59.01.png" alt="截屏2022-01-18 上午10.59.01" style="zoom:50%;" />

### 2.1.4 进程控制

功能有：创建新进程、撤销已有进程、实现进程状态转换

如何实现？ ----> 用==原语==实现，原语（运行在核心态）的特点是执行期间不允许中断，不可以被中断的操作即==原子操作==；采用“关中断指令”和“开中断指令”实现

不管什么原语，主要做三件事：

1. 更新PCB信息（修改状态标志、从PCB恢复运行环境等）
    1. 所有进程控制原语一定会修改进程状态标志
    2. 剥夺当前运行进程CPU使用权必然需要保存起运行环境
    3. 某进程开始运行前必然要恢复期运行环境
2. 将PCB插入合适队列
3. 分配/回收资源

相关原语

- 进程的创建
- 进程的终止
- 进程的阻塞
- 进程的唤醒
- 进程的切换

### 2.1.5 进程通信

进程之间的信息交换。进程是分配系统资源的单位（包括内存地址空间），各个进程拥有的内存地址空间相互独立。

#### 共享存储

![截屏2022-01-18 上午11.55.10](/Users/ryan/Documents/notes/images/os/截屏2022-01-18 上午11.55.10.png)

#### 管道通信

“管道”是用于连接读写进程的一个共享文件，又名pipe文件。即在内存中开辟一个大小固定的缓冲区。（Linux系统中频繁使用）

<img src="/Users/ryan/Documents/notes/images/os/截屏2022-01-18 上午11.57.34.png" alt="截屏2022-01-18 上午11.57.34" style="zoom:50%;" />

#### 消息传递

进程间数据交换以Message为单位。进程通过OS提供的“发送/接收消息”两个原语进行交换

两种方式

- 直接通信方式

<img src="/Users/ryan/Documents/notes/images/os/截屏2022-01-18 上午12.00.21.png" alt="截屏2022-01-18 上午12.00.21" style="zoom:33%;" />

- 间接通信方式

<img src="/Users/ryan/Documents/notes/images/os/截屏2022-01-18 上午12.04.59.png" alt="截屏2022-01-18 下午12.04.59" style="zoom:33%;" />

### 2.1.6 线程、多线程模型

引入线程的原因：有的进程需要同时做很多事情，传统进程只能串行执行，引入线程增加并发度。

线程最直接的理解是“轻量级进程”，是一个基本的CPU执行单元

#### 引入线程后，变化？

<img src="/Users/ryan/Documents/notes/images/os/截屏2022-01-18 下午8.18.43.png" alt="截屏2022-01-18 下午8.18.43" style="zoom:50%;" />

**为什么可以增加并发性？**

线程切换时，可能发生进程切换也可能不发生进程切换，平均每次切换所需要的开销变小了，能够让更多的线程参与并发，不会影响到响应时间等问题。

#### 线程的实现方式

两种方式：

- 用户级线程（User-Level Thread, ULT）

<img src="/Users/ryan/Documents/notes/images/os/截屏2022-01-18 下午8.24.44.png" alt="截屏2022-01-18 下午8.24.44" style="zoom:40%;" />

- 内核级线程（Kernel-Level Thread, KLT, 又称为“内核支持的编程”）

    <img src="/Users/ryan/Documents/notes/images/os/截屏2022-01-18 下午8.28.04.png" alt="截屏2022-01-18 下午8.28.04" style="zoom:50%;" />

- 组合方式：将n个用户级线程映射到m个内核级线程上（n>=m）

    <img src="/Users/ryan/Documents/notes/images/os/截屏2022-01-18 下午8.30.24.png" alt="截屏2022-01-18 下午8.30.24" style="zoom:50%;" />

==操作系统只看得见内核级线程，因此只有内核级线程才是处理机分配的单位==

例：上图，该进程2个内核级线程，3个用户级线程，用户看来有三个线程，该进程即使在4核处理机的计算机上运行，最多只能分配到两个核，最多只能有两个用户线程并发执行

#### 多线程模型

- 多对一模型
    - 多个用户线程映射一个内核级线程
    - 优点：用户级线程切换不需要切换到核心态
    - 缺点：当一个用户级线程阻塞后，整个进程都被阻塞，并发度低
- 一对一模型
    - 将每个用户级线程映射到一个内核级线程
    - 优点：并发能力强，多线程可以在多核处理机上并发执行
    - 缺点：一个用户进程会占用多个内核级线程，线程切换要切换到核心态，线程管理成本高
- 多对多模型（组合模型）
    - 相比来说更合理

## 2.2 处理机调度

### 2.2.1 调度的概念

当有一堆任务需要处理时，由于资源有限，无法同时进行处理，需要确定某种规则来决定处理这些任务的顺序

#### 调度的三个层次

一个作业从提交开始直到完成，需要经历三级调度：

1）作业调度，又称高级调度

按照一定原则从外存上处于后备状态的作业中选择一个或多个作业，给他们分配内存、输入/输出设备等必要的资源，并建立相应的进程（建立PCB），使它们获得竞争处理机的权利。

2）中级调度，又称内存调度

将那些暂时不能运行的进程调至外存等待，此时进程状态变为挂起态，（PCB不会调到外存，会常驻内存）等重新具备运行条件且内存又有空闲时，重新调入内存，修改为就绪态。一个进程可能被多次调出调入内存，而高级调度只会发生一次。

目的是提高内存利用率和系统吞吐量。

3）进程调度，又称低级调度

主要任务是按照某种方法和策略从就绪队列中选取一个进程，将处理机分配给他。    

进程调度是操作系统中最基本的一种调度

<img src="/Users/ryan/Documents/notes/images/os/截屏2022-02-15 下午4.43.37.png" alt="截屏2022-02-15 下午4.43.37" style="zoom:80%;" />

#### 补：挂起状态和七状态模型

中级调度中暂调到外存等待的进程状态为挂起状态（suspend），挂起状态又可以细分为就绪挂起和阻塞挂起。

<img src="/Users/ryan/Documents/notes/images/os/截屏2022-02-15 下午4.01.40.png" alt="截屏2022-02-15 下午4.01.40" style="zoom: 33%;" />

挂起和阻塞区别：都暂时无法获得CPU服务，但挂起态是将进程映像调到外存中，阻塞态下进程映像还在内存中。

### 2.2.2 调度的时机、切换与过程

进程调度（低级调度）：按某种算法从就绪队列中选择一个进程为其分配处理机。

- 需要进行进程调度与切换的情况：
    - 运行的进程主动放弃处理机。（正常终止，进程主动请求阻塞，运行中发生异常而终止）
    - 运行的进程被动放弃处理机。（分给进程的时间片用完，I/O中断，更高优先级的进程进入就绪队列）
- 不能进行进程调度与切换的情况
    - 处理中断的过程。
    - 进程在操作系统内核程序临界区。
    - 其他需要完全屏蔽中断的原子操作过程中（原语）。（例：修改PCB中进程状态标志，并把PCB放到相应队列中）

### 2.2.3 进程调度方式

所谓进程调度方式，是指当某个进程正在处理机上执行时，若有某个更为重要或紧迫的进程需要处理，即有优先权更高的进程进入就绪队列，此时应如何分配处理机。

两种进程调度方式：

- 非剥夺调度方式，又称非抢占方式。指当一个进程正在处理机上执行时，即使有某个更为重要或紧迫的进程进入就绪队列，仍让正在执行的进程仅需执行，直到进程完成或发生某种事件进入阻塞态。

    在这种方式下，一旦把CPU分配给一个进程，该进程就会保持CPU知道终止或转换到等待态。

- 剥夺调度方式，又称抢占方式。剥夺调度方式是指当一个进程正在处理机上执行时，若有某个更为重要或紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给这个更为重要或紧迫的进程。

    采用剥夺式的调度，对提高系统吞吐率和响应效率都有明显的好处。但“剥夺”不是 种任意性行为，必须遵循一定的原则，主要有优先权、短进程优先和时间片原则等。

### 2.2.4 调度算法评价指标

1）CPU利用率

​	指CPU“忙碌”的时间占总时间的比例。

​	==利用率== = 忙碌时间/总时间

2）系统吞吐量

​	表示单位时间内CPU完成作业的数量

​	==系统吞吐量== = 总共完成多少道作业 / 总共花了多少时间

3）周转时间

​	从昨夜被提交到系统开始，到作业完成为止的这段时间间隔

​	==周转时间== = 作业完成时间 - 作业提交时间

​	==平均周转时间== = 各作业周转时间之和 / 作业数

​	==带权周转时间== = 作业周转时间 / 作业实际运行时间

​	==平均带权周转时间== = 各作业带权周转时间之和 / 作业数

4）等待时间

​	进程/作业处于等待处理机状态时间之和

5）响应时间

​	用户提交请求到首次产生响应所用的时间

### 2.2.5 调度算法

#### 先来先服务（FCFS）

- 算法思想：“公平角度”
- 算法规则：按照作业/进程到达的先后顺序进行服务
- 用于作业/进程调度：用于作业调度时，考虑哪个作业先到达后备队列；用于进程调度时。考虑哪个进程先到达就绪队列。
- 是否可抢占：非抢占式算法
- 优缺点
    - 优点：公平、算法实现简单
    - 缺点：排在长作业（进程）后的短作业需要等待很长时间，带权周转时间大，短作业用户体验差。FCFS算法对长作业有利，对短作业不利
- 是否导致饥饿（某进程/作业长期得不到服务）：不会

#### 短作业优先（SJF，Shortest Job First）

- 算法思想：追求最少的平均等待时间，最少的平均周转时间、最少的平均带权周转时间。
- 算法规则：最短的作业/进程优先得到服务(所谓“最短”，是指要求服务时间最短)
- 用于作业/进程调度：即可用于作业调度，也可用于进程调度。用于进程调度时称为“短进程优先(SPF，Shortest Process First)算法”
- 是否可抢占：SJF和SPF是非抢占式的算法。但是也有抢占式的版本ー一==最短剩余时间优先算法==(SRTN，Shortest Remaining Time Next)
- 优缺点
    - 优点：“最短的”平均等待时间、平均周转时间（SRTN更短）
    - 缺点：不公平。对短作业有利，对长作业不利，可能会产生饥饿现象。另外，作业/进程的运行时间由用户提供，不一定真实，不一定做到真正短作业优先。
- 是否导致饥饿（某进程/作业长期得不到服务）：会。如果源源不断地有短作业/进程到来，可能使长作业/进程长时间得不到服务，产生“饥饿”现象。如果一直得不到服务，则称为“饿死”。

#### 高响应比优先（HRRN，Highest Response Ratio Next）

- 算法思想：综合考虑作业/进程的等待时间和要求服务的时间。

- 算法规则：每次调度时计算响应比，选择响应比最高的作业/进程为其服务

    ==响应比== = （等待时间 + 要求服务时间） / （要求服务时间）

- 用于作业/进程调度：都可

- 是否可抢占：非抢占式。因此只有当前运行的作业/进程主动放弃处理机时，才需要调度，才需要计算响应比

- 优缺点：综合考虑了等待时间和运行时间(要求服务时间) 等待时间相同时，要求服务时间短的优先(SF的优点) 要求服务时间相同时，等待时间长的优先(FCFS的优点) 对于长作业来说，随着等待时间越来越久，其响应比也会越来越大，从而避免了长作业饥饿的问题

- 是否导致饥饿（某进程/作业长期得不到服务）：不会

注：这几种算法主要关心对用户的公平性、平均周转时间、平均等待时间等评价系统整体性能的指标，但 是不关心“响应时间”，也并不区分任务的紧急程度，因此对于用户来说，交互性很糟糕。因此这三种算法一般适合用于早期的批处理系统。（FCFS算法也常结合其他的算法使用，在现在也扮演着很重要的角色）

#### 时间片轮转调度算法（RR，Round-Robin）

- 算法思想：公平轮流地为各个进程服务，让每个进程在一定时间间隔内都可以得到响应
- 算法规则：按照各进程到达就绪队列的顺序，轮流让各个进程执行个时间片(如100ms)。若进程未在一个时间片内执行完， 则剥夺处理机，将进程重新放到就绪队列队尾重新排队。
- 用于作业/进程调度：用于进程调度（只有作业放入内存建立了相应的进程后，才能被分配处理机时间片）
- 是否可抢占：若进程未能在时间片内运行完，将被强行剥夺处理机使用权，因此时间片轮转调度算法属于抢占式的算法。由时钟装置发出时钟中断来通知CPU时间片已到
- 优缺点：
    - 优点：公平，响应快，适合分时操作系统。
    - 缺点：进程切换频率高，会造成一定开销；不区分任务的紧急程度。
- 是否会导致饥饿：不会

#### 优先级调度算法

- 算法思想：随着计算机的发展，特别是实时操作系统的出现，越来越多的应用场景需要根据**任务的紧急程度**来决定处理顺序
- 算法规则：调度时选择优先级最高的作业/进程
- 用于作业/进程调度：都可以，还可以用于I/O调度
- 是否可抢占：抢占式，非抢占式的都有
- 优缺点：
    - 优点：用优先级区分紧急程度、重要程度，适用于实时操作系统。可灵活地调整对各种作业/进程的偏好程度。
    - 缺点：若源源不断地有高优先级进程到来，则可能导致饥饿
- 是否会导致饥饿：会

补充：优先级可以分为==静态优先级==（创建进程时确定，之后一直不变），==动态优先级==（创建进程时有一个初始值，之后会根据情况动态地调整优先级）

- 如何合理设置各类进程优先级？
    - 系统进程优先级高于用户进程
    - 前台进程优先级高于后台进程
    - 操作系统更偏好==I/O型进程==（I/O繁忙行进程），与之相对的是==计算型进程==（CPU繁忙型进程）
- 采用动态优先级，何时调整？（追求公平、提升资源利用率等角度）
    - 如果某进程在就绪队列中等待了很长时间，则可以适当提升其优先级
    - 如果某进程占用处理机运行了很长时间，则可适当降低其优先级
    - 如果发现一个进程频繁地进行/O操作，则可适当提升其优先级

#### 多级反馈队列调度算法（融合前几种算法的优点）

- 算法思想：对其他调度算法的折中
- 算法规则：
    - 设置多级就绪队列，各级队列优先级从高到低，时间片从小到大
    - 新进程到达时先进入第1级队列，按FCFS原则排队等待被分配时间片，若用完时间片进程还未结束，则进程进入下一级队列队尾；如果此时已经是在最下级的队列，则重新放回该队列队尾
    - 只有第k级队列为空时，才会为k+1级队头的进程分配时间片
- 用于作业/进程调度：进程调度
- 是否可抢占：抢占式算法。在k级队列的进程运行过程中，若更上级的队列 (1 ~ k-1 级)中进入了一个新进程，则由于新进程处于优先级更高的队列中，因此新进程会抢占处理机，原来运行的进程放回k级队列的队尾。
- 优缺点：
    - 对各类型进程相对公平(FCFS的优点)；
    - 每个新到达的进程都可以 很快就得到响应(RR的优点)；
    - 短进程只用较少的时间就可完成 (SPF的优点)；
    - 不必实现估计进程的运行时间(避免用户作假) ;
    - 可灵活地调整对各类进程的偏好程度，比如CPU密集型进程、I/O 密集型进程(拓展：可以将因 I/O 而阻塞的进程重新放回原队列，这样 I/O型进程就可以保持较高优先级)
- 是否会导致饥饿：会

例题：

![截屏2022-02-16 下午5.20.15](/Users/ryan/Documents/notes/images/os/截屏2022-02-16 下午5.20.15.png)

## 2.3 进程同步

### 2.3.1 进程同步和进程互斥

读进程和写进程并发地运行，由于并发必然导致异步性，因此“写数据”和“读数据”两个操作执行的先后顺序是不确定的。而实际应用中，又必须按照“写数据→读数据”的顺序来执行的。 如何解决这种异步问题，就是“进程同步”所讨论的内容。

同步指直接制约关系，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的**工作次序**而产生的制约关系。进程间的制约关系就是源于它们之间的互相合作。

互斥也称间接制约关系。当一个进程进入临界区使用临界资源时，另一个进程必须等待，当占用临界资源的进程退出临界区后，另一进程才允许去访问此临界资源。

临界资源：一个时间段内只允许一个进程使用

实现对临界区的互斥访问：

```c
do {
	entry section;		//进入区
	critical section;	//临界区
	exit section;		//退出区
	remainer section;	//剩余区
} while(true)
```

为了禁止两个进程同时进入临界区，同步应遵循的原则：

1）空闲让进。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区。

2）忙则等待。当已有进程进入临界区时，其他试图进入临界区的进程必须等待。

3）有限等待。对请求访问的进程，应保证能在有限时间内进入临界区。

4）让权等待。当进程不能进入临界区时，应立即释放处理器，防止进程忙等待。

### 2.3.2 进程互斥的软件实现方法

#### 单标志法

-  算法思想：两个进程在访问完临界区后会把临界区的权限转交给另一个进程。也就是说每一个进程进入临界区的权限只能被另一个进程赋予。<img src="/Users/ryan/Documents/notes/images/os/截屏2022-02-16 下午8.16.33.png" alt="截屏2022-02-16 下午8.16.33" style="zoom: 33%;" />
- 这种必须“轮流访问”带来的问题是，如果此时允许进入临界区的进程是P0，而P0一直不访问临界区，那么虽然此时临界区空闲，但是并不允许P1访问。
- 因此，单标志法存在的主要问题是：==违背“空闲让进”原则==。

#### 双标志先检查法

- 算法思想：设置一个布尔型数组flag[]，数组中各个元素用来标记各进程想进入临界区的意愿，比如 flag[0]=ture 意味着0号进程P0现在想要进入临界区。每个进程在进入临界区之前先检査当前有没有别的进程想进入临界区，如果没有，则把自身对应的标志flag[i]设为true，之后开始访问临界区。<img src="/Users/ryan/Documents/notes/images/os/截屏2022-02-16 下午8.21.57.png" alt="截屏2022-02-16 下午8.21.57" style="zoom: 33%;" />
- 若按照152637顺序执行，P0和P1同时访问临界区。（原因在于，进入区的“检査”和“上锁”两个处理不是一气呵成的。“检査”后，“上锁”前可能发生进程切换。）
- 双标志先检查法主要问题：==违反“忙则等待”原则==

#### 双标志后检查法

- 算法思想：双标志先检査法的改版：先“上锁”后“检查” 的方法。<img src="/Users/ryan/Documents/notes/images/os/截屏2022-02-16 下午8.28.37.png" alt="截屏2022-02-16 下午8.28.37" style="zoom: 33%;" />
- 按照1526，P0和P1都无法进入临界区
- 解决了双标志先检查法的“忙则等待问题”，又==违反了“空闲让进”和“有限等待”原则==，会产生饥饿现象

#### Peterson Algorithm

- 算法思想：根据双标志后检查法出现的问题，让进程尝试“孔融让梨”，主动让对方先使用临界区。<img src="/Users/ryan/Documents/notes/images/os/截屏2022-02-16 下午8.32.19.png" alt="截屏2022-02-16 下午8.32.19" style="zoom:33%;" />
- Peterson算法用软件方法解决了进程互斥问题，遵循了空闲让进、忙则等待、有限等待三个原则，但是依然未遵循让权等待的原则。

### 2.3.3 进程互斥的硬件实现方法

#### 中断屏蔽方法

- 利用“开/关中断指令实现”
- 优点：简单、高效
- 缺点：不适用于多处理机；只适用于操作系统内核进程，不适用于用户进程（开/关中断指令只能运行在内核态）

<img src="/Users/ryan/Documents/notes/images/os/截屏2022-02-16 下午8.58.09.png" alt="截屏2022-02-16 下午8.58.09" style="zoom:50%;" />

#### TestAndSet指令

TS指令（TSL指令）：用硬件实现，执行中不允许被中断。

```C
//布尔型共享变量 lock 表示当前临界区是否被加锁
//ture 表示已加锁，false 表示未加锁
bool TestAndSet (bool *lock){
    bool old;
    old = *lock;	//old 用来存放 lock 原来的值
    *lock = true;	//无论之前是否已加锁，都将 lock 设为 true
    return old； 	//返回 lock 原来的值
}
```

使用TS指令实现互斥的算法逻辑

```C
while (TestAndSet (&lock));//“上锁”并“检查”
临界区代码段...	
lock = false;	//解锁
剩余区代码段...
```

- 优点：简单，把“上锁”和“检查”变成了一气呵成的院子操作；适用于多处理机环境
- 缺点：不满足“让权等待”原则

#### Swap指令

也称Exchange指令（XCHG）指令，硬件实现

```C
Swap (bool *a, *b) {
    bool temp;
    temp = *a;
    *a = *b;
    *b = temp;
}
```

使用Swap指令实现互斥的算法逻辑

```C
bool old = true;
while (old == true)
    Swap(&lock, &old);
临界区代码段...
lock = false;	//解锁
剩余区代码段...
```

逻辑与TSL并无太大区别。

### 2.3.4 信号量

用户进程可以通过使用操作系统提供的一对原语来对信号量进行操作，从而很方便的实现了进程互斥、进程同步。

一对原语：wait(S)原语和 signal(S)原语，（P、V操作）可以把原语理解为我们自己写的函数，函数名分别为wait 和 signal，括号里的信号量S其实就是函数调用时传入的一个参数

#### 整型信号量

用一个整数型的变量作为信号量，表示系统中某种资源的数量。（信号量的操作只有三中全会：初始化、P操作、V操作）（不满足“让权等待”）

Eg：

```C
int S = 1;	//初始化整型信号量S，表示当前系统中可用打印机资源数

void wait (int &S) {		//wait原语，相当于“进入区”
    while (S <= 0);		//如果资源数不够，循环等待
    S = S - 1;			//资源数够，占用一个资源
}

void signal (int &S) {	//sinal原语，相当于“退出区”
    S = S + 1;			//使用完资源，在退出区释放资源
}

进程P0:
...
wait(S);			//进入区，申请资源
使用打印机资源...		//临界区，访问资源
signal(S);			//退出区，释放资源
...
```

#### 记录型信号量

```c
// 记录型信号量的定义
typedef struct {
    int value:			//剩余资源数
	struct process *L;	//等待队列
} semaphore;

//某进程需要使用资源时，通过 wait 原语申请
void wait(semaphore S) {
    S.value--;
    if (S.value < 0){
        block(S.L);		//剩余资源数不够，使用 block 原语使进程从运行态进入阻塞态，挂到等待队列
    }
}

//进程使用完资源，通过 signal 原语释放
void signal(semaphore S) {
    S.value++;
    if (S.value <= 0){
        wakeup(S.L);	
        //释放资源后，若还有别的进程等待这种资源，使用 wakeup 原语唤醒等待队列中的一个进程，将其由			阻塞态变为就绪态
    }
}
```

对信号量S的一次P操作意味着进程请求一个单位的该类资源，因此需要执行 S. value-- ，表示资源数减1，当
S.value < 0 时表示该类资源已分配完毕，因此进程应调用 block原语进行==自我阻塞==(当前运行的进程从运行态 阻塞态)，主动放弃处理机，并插入该类资源的等待队列S.L中。可见，该机制遵循了“让权等待”原则，不会出现“忙等”现象。
对信号量S的一次V操作意味着进程释放一个单位的该类资源，因此需要执行 S.value++ ，表示资源数加1， 若加1后仍是 S. value <= 0，表示依然有进程在等待该类资源，因此应调用 wakeup 原语唤醒等待队列中的第一个进程(被唤醒进程从阻塞态￫就绪态)。

### 2.3.5 用信号量机制实现进程互斥、同步、前驱

#### 信号量机制实现进程互斥

![截屏2022-02-17 下午4.00.39](/Users/ryan/Documents/notes/images/os/截屏2022-02-17 下午4.00.39.png)

#### 信号量机制实现进程同步

<img src="/Users/ryan/Documents/notes/images/os/截屏2022-02-17 下午4.04.54.png" alt="截屏2022-02-17 下午4.04.54" style="zoom:100%;" />

#### 信号量机制实现前驱关系

![截屏2022-02-17 下午4.08.33](/Users/ryan/Documents/notes/images/os/截屏2022-02-17 下午4.08.33.png)

### 2.3.6 经典同步问题

#### 生产者 —— 消费者问题

##### 问题描述：

- 系统中有一组生产者进程和一组消费者进程，生产者进程每次生产一个产品放入缓冲区，消费者进程每次从缓冲区中取出一个产品并使用。(注：这里的“产品”理解为某种数据) 
- 生产者、消费者共享一个初始为空、大小为n的缓冲区。
- 只有缓冲区没满时，生产者才能把产品放入缓冲区，否则必须等待。（同步关系）
- 只有缓冲区不空时，消费者才能从中取出产品，否则必须等待。（同步关系）
- 缓冲区是临界资源，各进程必须互斥地访问。（互斥关系）

##### 问题分析：

- 生产者每次要消耗(P)一个空闲缓冲区，并生产(V)一个产品。

- 消费者每次要消耗(P)一个产品，并释放一个空闲缓冲区(V)。

- 往缓冲区放入/取走产品需要互斥。

##### 如何实现：

```c
semaphore mutex = 1;		//互斥信号量，实现对缓冲区的互斥访问
semaphore empty = n;		//同步信号量，表示空闲缓冲区的数量
semaphore full = 0;			//同步信号量，表示产品数量，也即非空缓冲区的数量

producer() {				//生产者进程
    while(1){
        生产一个产品;			//生产数据
        P(empty);			//获取空缓冲区单元
        P(mutex);			//进入临界区
        把产品放入缓冲区;
        V(mutex);			//离开临界区，释放互斥信号量
        V(full);			//满缓冲区加1
    }
}

consumer() {				//消费者进程
    while(1){				
        P(full);			//获取满缓冲区单元
        P(mutex);			//进入临界区
        从缓冲区取出一个产品;
        V(mutex);			//离开临界区，释放互斥信号量
        V(empty);			//空缓冲区数加1
        使用产品;
    }
}
```

#### 多生产者 —— 多消费者问题

##### 问题描述：

桌子上有一只盘子，每次只能向其中放入一个水果。爸爸专向盘子中放苹果，妈妈专向盘子中放橘子，儿子专等着吃盘子中的橘子，女儿专等着吃盘子中的苹果。只有盘子空时，爸爸或妈妈才可向盘子中放一个水果。仅当盘子中有自己需要的水果时，儿子或女儿可以从盘子中取出水果。用PV操作实现上述过程。

图例：

![截屏2022-02-17 下午5.09.30](/Users/ryan/Documents/notes/images/os/截屏2022-02-17 下午5.09.30.png)

##### 问题分析：

- 互斥关系：对缓冲区的访问要互斥进行
- 同步关系：
    - 父亲将苹果放入盘子后，女儿才能取苹果。
    - 母亲将橘子放入盘子后，儿子才能取橘子。 
    - 只有盘子为空时，父亲或母亲才能放入水果。

<img src="/Users/ryan/Documents/notes/images/os/截屏2022-02-17 下午5.12.37.png" alt="截屏2022-02-17 下午5.12.37" style="zoom:50%;" />

##### 如何实现：

```c
//即使不设置专门的互斥变量mutex，也不会出现多个进程同时访问盘子的现象，原因在缓冲区大小为1，任何时 	刻，三个同步信号量最多只有一个是1。在任何时刻，最多只有一个进程的P操作不会被阻塞，并顺利进入临界区	。如果缓冲区大小大于1，则需要互斥信号量mutex
semaphore apple = 0;		//盘子中有几个苹果
semaphore orange = 0;		//盘子中有几个橘子
semaphore plate = 1;		//盘子中还可以放多少个水果

dad() {						//父亲进程
    while(1){
        准备一个苹果;
        P(plate);			//互斥向盘中取、放水果
        把苹果放入盘子;
        V(apple);			//允许取苹果
    }
}

mom() {						//母亲进程
    while(1){
        准备一个橘子;
        P(plate);			//互斥向盘中取、放水果
        把橘子放入盘子;
        V(orange);			//允许取橘子
    }
}

son() {						//儿子进程
    while(1){
        P(orange);			//互斥向盘中取橘子
        从盘中取出橘子;
        V(plate);			//允许向盘中取、放水果
        吃橘子;
    }     
}

daughter() {				//女儿进程
    while(1){
        P(apple);			//互斥向盘中取苹果
        从盘中取出苹果;
        V(plate);			//允许向盘中取、放水果
        吃苹果;
    }     
}
```

#### 读者 —— 写者问题

##### 问题描述：

有读者和写者两组并发进程，共享一个文件，当两个或两个以上的读进程同时访问共享数据时不会产生副作用，但若某个写进程和其他进程(读进程或写进程)同时访问共享数据时则可能导致 数据不一致的错误。

因此要求：

①允许多个读者可以同时对文件执行读操作；

②只允许一个写者 往文件中写信息；

③任一写者在完成写操作之前不允许其他读者或写者工作；

④写者执行写操作前，应让已有的读者和写者全部退出。

![截屏2022-02-18 上午9.54.49](/Users/ryan/Documents/notes/images/os/截屏2022-02-18 上午9.54.49.png)

##### 问题分析：

两类进程：写进程、读进程

互斥关系：写进程 —— 写进程、写进程 —— 读进程。读进程和读进程不存在互斥问题。

- 写者进程和任何进程都互斥，设置一个互斥信号量rw，在写者访问共享文件前后分别执行P、V操作。
- 读者进程和写者进程也要互斥，因此读者访问共享文件前后也要对rw执行P、V操作。
- 如果所有读者进程在访问共享文件之前都执行P(rw)操作，那么会导致各个读进程之间无法同时访问文件。

##### 如何实现：

```c
semaphore rw = 1;				//用于记录当前的读者数量
int count = 0;					//用于保护更新 count 变量时的互斥	
semaphore mutex = 1;			//用于保证读者和写者互斥地访问文件
semaphore w = 1;				//实现“写优先”

writer() {						//写者进程
    while(1){
        P(w);					//在无写进程请求时进入
        P(rw);					//互斥访问共享文件
        writing;
        V(rw);					//释放共享文件
        V(w);					//恢复对共享文件的访问
    }
}

reader() {						//读者进程
    while(1){
        P(w);					//在无写进程请求时进入
        P(mutex);				//互斥访问 count变量
        if(count == 0)			//当第一个读进程读共享文件时
            P(rw);				//组织写进程写
        count++;				//读者计数器+1
        V(mutex);				//释放互斥变量 count
        V(w);					//恢复对共享文件的访问
        reading;
        P(mutex);
        count--;				
        if(count == 0)			//当最后一个读进程读完共享文件
            V(rw);				//运训写进程写
        V(mutex);
    }
}
```

#### 哲学家进餐问题

##### 问题描述：

一张圆桌上坐着5名哲学家，每两个哲学家之间的桌上摆一根筷子，桌子的中间是一碗米饭。哲学家们倾注毕生的精力用于思考和进餐，哲学家在思考时，并不影响他人。只有当哲学家饥饿时，才试图拿起左、右两根筷子(一根一根地拿起)。如果筷子已在他人手上，则需等待。饥饿的哲学家只有同时拿起两根筷子才可以开始进餐，当进餐完毕后，放下筷子继续思考。

##### 问题分析：

这个问题中只有互斥关系，但与之前遇到的问题不同的事，每个哲学家进程需要同时持有两个临界资源才能开始吃饭。如何避免临界资源分配不当造成的死锁现象，是哲学家问题的精髓。

信号量设置：定义互斥信号量数组 chopstick[5]={1，1，1，1，1}用于实现对5个筷子的互斥访问。并对哲学家按0~4编号，哲学家 i 左边的筷子编号为 i ，右边的筷子编号为 (i+1)%5。

<img src="/Users/ryan/Documents/notes/images/os/截屏2022-02-18 上午10.20.52.png" alt="截屏2022-02-18 上午10.20.52" style="zoom:50%;" />

##### 如何实现：

当一名哲学家左右两边的筷子都可用时，才允许他抓起筷子

```c
semaphore chopstick[5] = {1,1,1,1,1};
semaphore mutex = 1;					//取筷子信号量
Pi() {
    while(1){
        P(mutex);
        P(chopstick[i]);				//取左边筷子
        P(chopstick[(i+1)%5]);			//取右边筷子 
        V(mutex);
        eat;
        V(chopstick[i]);
        V(chopstick[(i+1)%5]);
        think;
    }
}
```

### 2.3.7 管程

管程是一种特殊的软件模块：（加锁，java synchronized）

- 局限于管程的共享数据结构说明；
- 对该数据结构进行操作的一组过程；
- 对局部于管程的共享数据设置初始值的语句；
- 有一个名字

基本特征：

- 局部于管程的数据智能呗局部于管程的过程所访问；
- 一个进程只有通过调用管程内的过程才能进入管程访问共享数据；
- 每次仅允许一个进程在管程内执行某个内部过程。

## 2.4 死锁

定义：并发环境下，各进程因竞争资源而造成的一种互相等待对方手里的资源，导致各进程都阻塞，都无法向前推进的现象。

### 死锁产生的必要条件

产生死锁必须同时满足四个条件：

- 互斥条件：只有对必须互斥使用的资源的争抢才会导致死锁（哲学家的筷子）
- 不剥夺条件：进程所获的的资源在未使用完之前，==不能由其他进程强行夺走==，只能主动释放
- 请求和保持条件：进程已经==保持了至少一个资源==，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但对自己已有的资源保持不放。
- 循环等待条件：存在一种进程资源的循环等待链，

### 死锁产生的原因

- 系统资源的竞争：对==不可剥夺的资源的竞争==（打印机）
- 进程推进顺序非法：请求和释放资源顺序不当。如：并发进程P1，P2分别保持了资源R1，R2，而进程P1申请资源R2、进程P2申请资源R1时，两者都会因为所需资源被占用而阻塞，产生死锁。

### 死锁的处理策略

- 预防死锁（破坏死锁产生的四个必要条件）

- 避免死锁

    - 安全序列：指如果系统按照这种序列分配资源，则每个进程都能顺利完成。只要能找出一个安全序列，系统就是==安全状态==。当然，安全序列可能有多个。
    - 如果系统处于安全状态，就一定不会发生死锁。如果系统进入不安全状态，就可能发生死锁(处于不安全状态未必就是发生了死锁，但发生死锁时一定是在不安全状态)

    银行家算法（核心思想：在资源分配之前预先判断这次分配是否会导致系统进入不安全状态）

    ![截屏2022-02-18 下午1.57.58](/Users/ryan/Documents/notes/images/os/截屏2022-02-18 下午1.57.58.png)

- 死锁的检测和解除

    - 死锁的检测

        <img src="/Users/ryan/Documents/notes/images/os/截屏2022-02-18 下午2.04.13.png" alt="截屏2022-02-18 下午2.04.13" style="zoom:67%;" />

        如果系统中剩余的可用资源数可以满足进程的需求，通过分析，能够消除所有边，称这个图可以被简化，一定没有发生死锁。（找到一个安全序列）

        会发生死锁的情况：（只有P3能运行，P3结束后归还一个R2资源，但P1需要两个，发生阻塞，同时P2需要申请一个R1资源，但由于R1资源已经被分配给P1和P2，也发生阻塞，导致死锁）

        <img src="/Users/ryan/Documents/notes/images/os/截屏2022-02-18 下午2.09.07.png" alt="截屏2022-02-18 下午2.09.07" style="zoom:50%;" />

    - 死锁的解除

        - ==资源剥夺法==。挂起(暂时放到外存上)某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但是应防止被挂起的进程长时间得不到资源而饥饿。
        - ==撤销进程法==(或称终止进程法)。强制撤销部分、甚至全部死锁进程，并剥夺这些进程的资源。这种方式的优点是实现简单，但所付出的代价可能会很大。因为有些进程可能已经运行了很长时间，已经接近结束了，一旦被终止可谓功亏一篑，以后还得从头再来。
        - ==进程回退法==。让一个或多个死锁进程回退到足以避免死锁的地步。这就要求系统要记录进程的历史信息，设置还原点。

​	
