# 第三章 内存管理

<img src="/Users/ryan/Documents/notes/images/os/截屏2022-02-18 下午2.20.00.png" alt="截屏2022-02-18 下午2.20.00" style="zoom:50%;" />

## 3.1 内存管理

### 3.1.1 内存基础知识

内存是存放数据的硬件。程序执行前==需要放到内存才能被CPU处理==

给内存的存储单元编地址

单位：

<img src="/Users/ryan/Documents/notes/images/os/截屏2022-02-19 上午10.40.14.png" alt="截屏2022-02-19 上午10.40.14" style="zoom: 33%;" />

#### 进程的运行原理 —— 指令

我们写的代码要翻译成CPU能识别的指令。这些指令会告诉CPU应该去内存的哪个地址存/取数据，这个数据应该做什么样的处理。



#### 逻辑地址 vs 物理地址

- 逻辑地址：编译后，每个目标模块从0号单元开始编址，不同进程可以有相同的逻辑地址，这些逻辑地址可以映射到主存的不同位置。
- 物理地址：地址转换的最终地址，进程在运行时执行指令和访问数据，最后都要通过物理地址从主存中存取。
- 编译时产生的指令只关心“相对地址”，实际放入内存中时再想办法根据起始位置得到“绝对地址”

#### 程序执行的步骤

<img src="/Users/ryan/Documents/notes/images/os/截屏2022-02-19 上午11.13.20.png" alt="截屏2022-02-19 上午11.13.20" style="zoom:50%;" />

装入的三种方式（逻辑地址到物理地址的转换）：

- 绝对装入

    在编译时，如果知道程序将放到内存中的哪个位置，编译程序将产生绝对地址的目标代码。 装入程序按照装入模块中的地址，将程序和数据装入内存。

- 静态重定位

    又称可重定位装入。编译、链接后的装入模块的地址都是从0开始的，指令中使用的地址、数据存放的地址都是相对于起始地址而言的逻辑地址。可根据内存的当前情況，将装入模块装入到内存的适当位置。装入时对地址进行“重定位”，将逻辑地址变换为物理地址(地址变换是在装入时一次完成的)。

    作业再装入内存时，必须分配其要求的全部内存空间。

- 动态重定位

    又称动态运行时装入。编译、链接后的装入模块的地址都是从0开始的。装入程序把装入模块装入内存后，并不会立即把逻辑地址转换为物理地址，而是把地址转换推迟到程序真正要执行时才进行。因此装入内存后所有的地址依然是逻辑地址。这种方式需要一个==重定位寄存器==的支持。（存放装入模块存放的起始位置）

    允许程序在内存中发生移动，可以在程序运行期间，根据需要动态申请分配内存

    <img src="/Users/ryan/Documents/notes/images/os/截屏2022-02-19 下午2.42.12.png" alt="截屏2022-02-19 下午2.42.12" style="zoom:50%;" />

链接的三种方式：

- 静态链接
- 装入时链接
- 运行时动态链接（便于修改和更新）

内存管理的概念：

<img src="/Users/ryan/Documents/notes/images/os/截屏2022-02-19 上午11.23.12.png" alt="截屏2022-02-19 上午11.23.12" style="zoom:50%;" />

### 3.1.2 覆盖与交换

覆盖技术：解决“程序大小超过物理内存总和”的问题

![截屏2022-02-19 上午11.25.07](/Users/ryan/Documents/notes/images/os/截屏2022-02-19 上午11.25.07.png)

例子：

<img src="/Users/ryan/Documents/notes/images/os/截屏2022-02-19 上午11.27.03.png" alt="截屏2022-02-19 上午11.27.03" style="zoom:50%;" />

交换技术：内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存（进程在内存与磁盘间动态调度）

==中级调度==（内存调度），就是决定将哪个处于挂起状态的进程重新调入内存

![截屏2022-02-19 上午11.32.46](/Users/ryan/Documents/notes/images/os/截屏2022-02-19 上午11.32.46.png)

PCB常驻内存

### 3.1.3 连续分配管理方式

#### 单一连续分配

![截屏2022-02-19 上午11.39.51](/Users/ryan/Documents/notes/images/os/截屏2022-02-19 上午11.39.51.png)

#### 固定分区分配

- 分区大小相等
- 分区大小不等

操作系统需要建立一个数据结构 —— 分区说明表

#### 动态分区分配

进程装入内存时，根据进程大小动态地建立分区

<img src="/Users/ryan/Documents/notes/images/os/截屏2022-02-19 上午11.44.32.png" alt="截屏2022-02-19 上午11.44.32" style="zoom:33%;" />

问题：

- 系统使用什么数据结构记录内存使用情况？

    两种常用数据结构：空闲分区表、空闲分区链

- 当有很多空闲分区都能满足需求时，选择哪个分区进行分配？

    动态分区分配算法：

    - 首次适应算法（First Fit）（综合效果最好）

        每次从低地址开始查找，找到第一个能满足大小的空闲分区。空闲分区以地址递增的次序排列

    - 最佳适应算法（Best Fit）

        尽可以能多地留下大片的空闲区，优先使用更小的空闲区。空闲分区按容量递增次序链接

        缺点：每次都选最小分区进行分配，会产生很多的外部碎片。

    - 最坏适应算法（Worst Fit）

        优先使用最大的连续空闲区。空闲分区按容量递减次序链接

        缺点：每次选最大分区进行分配，如果之后有“大进程”到达，就没有内存分区可用

    - 邻近适应算法（Next Fit）

        解决首次适应算法问题：每次都从链头开始查找的。这可能会导致低地址部分出现很多小的空闲分区。

        每次从上次查找结束的位置开始检索

- 如何进行分区的分配与回收？

​		修改空闲分区表

==内部碎片==：分配给某进程的内存区域，有些部分没有用上

==外部碎片==：内存中的某些空闲分区由于太小而难以利用

通过==紧凑==（Compaction）技术来解决外部碎片，“紧凑”之后需要修改进程的起始地址

### 3.1.4 非连续分配管理方式

与连续分配管理方式区别：非连续分配为用户进程分配的可以是一些==分散==的内存空间

#### 基本分页存储管理方式基本概念

基本分页存储管理的思想：把内存分为一个个相等的小分区，再按照分区的大小把进程拆分成一个个小部分

<img src="/Users/ryan/Documents/notes/images/os/截屏2022-02-19 下午2.36.01.png" alt="截屏2022-02-19 下午2.36.01" style="zoom:67%;" />

进程中的块称为页（Page），内存中的块称为页框（Page Frame）。进程在执行中需要申请主存空间，将进程的地址空间分为与页框大小的块（页/页面），要为每个页面分配主存中的可用页框，页面编号（页号）从0开始。进程的每个页面与内存的页框有一一对应关系

==连续存放==时，os如何实现逻辑地址到物理地址转换？
定义重定位寄存器，存放装入模块的起始位置，模块在内存中的“起始位置”+目标内存单元相对于起始位置的“偏移量”

<img src="/Users/ryan/Documents/notes/images/os/截屏2022-02-21 上午11.26.13.png" alt="截屏2022-02-21 上午11.26.13" style="zoom:50%;" />

采用==分页==技术如何实现地址转换

![截屏2022-02-21 上午11.27.20](/Users/ryan/Documents/notes/images/os/截屏2022-02-21 上午11.27.20.png)

假设指令1，需要访问逻辑地址为80的内存单元，如何转化？
计算“偏移量”，偏移量30，该页在内存中起始位置450，计算得到480（实际物理地址）

- 算逻辑地址对应页号
- 知道该页号对应页面在内存中的起始地址
- 算出逻辑地址在页面内的“偏移量”
- 物理地址 = 页面始址 + 页内偏移量

计算？
页号 = 逻辑地址 / 页面长度
业内偏移量 = 逻辑地址 % 页面长度
2进制更为简单计算，每个页面大小$2^KB$，末尾K位就是业内偏移量，其余部分为页号

**逻辑地址结构**

<img src="/Users/ryan/Documents/notes/images/os/截屏2022-02-21 上午11.34.59.png" alt="截屏2022-02-21 上午11.34.59" style="zoom:67%;" />

**页表**

记录==进程页面和实际存放的内存块之间的对应关系==，操作系统为每个进程建立一张页表

![截屏2022-02-21 上午11.36.19](/Users/ryan/Documents/notes/images/os/截屏2022-02-21 上午11.36.19.png)

**每个页表项长度相同，页号“隐含”？**

![截屏2022-02-21 上午11.54.28](/Users/ryan/Documents/notes/images/os/截屏2022-02-21 上午11.54.28.png)

#### 基本地址变换机构

任务：将逻辑地址转换为内存中的物理地址。

通常会在系统中设置一个页表寄存器(PTR)，存放页表在内存中的起始地址F和页表长度M。进程未执行时，页表的始址和页表长度放在进程控制块(PCB)中，当进程被调度时，操作系统内核会把它们放到页表寄存器中。

<img src="/Users/ryan/Documents/notes/images/os/截屏2022-02-21 上午9.49.43.png" alt="截屏2022-02-21 上午9.49.43" style="zoom:50%;" />

页表长度：这个页表中总共有几个页表项；

页表项长度：每个页表项占多大的存储空间；

页面大小：一个页面占多大的存储空间

#### 具有快表的地址变换机构

**局部性原理**：

- 时间局部性：执行了程序中的某条指令，不久后这条指令很可能再次执行；如果某个数据被访问过，不久后改数据很可能被再次访问（程序中有循环）

- 空间局部性：一旦程序访问了某个存储单元，不久后，其附近的存储单元也很可能被访问（数据在内存中连续存放的）

由于局部性原理，可能连续很多次查到的都是同一个页表项。

**快表**（联想寄存器，TLB），与快表对应，页表称为慢表。（快表存放页表的一部分副本），快表命中，只需一次访问内存；未命中，两次访存

<img src="/Users/ryan/Documents/notes/images/os/截屏2022-02-21 上午10.44.46.png" alt="截屏2022-02-21 上午10.44.46" style="zoom:50%;" />

#### 两级页表

单级页表问题：

1. 页表连续存放，页表很大时候，需要占用很多歌连续页框；

2. 没有必要让整个页表常驻内存，进程在一段时间可能只需要访问几个特定的页面

**解决问题1**

两级页表，将页表分组（与前面将地址空间分页，建立页表，记录各页面的存放位置相似）
为离散分配的页表再建立一张也考，称为==页目录表==

![截屏2022-02-21 下午1.53.15](/Users/ryan/Documents/notes/images/os/截屏2022-02-21 下午1.53.15.png)

**实现地址变换**

![截屏2022-02-21 下午1.54.47](/Users/ryan/Documents/notes/images/os/截屏2022-02-21 下午1.54.47.png)

**解决问题2**

在访问页面时才把页面调入内存（虚拟存储技术）。在页表项中增加一个标志位，标识该页面是否已经调入内存。

#### 基本分段存储管理方式

**分段**

![截屏2022-02-21 下午2.01.28](/Users/ryan/Documents/notes/images/os/截屏2022-02-21 下午2.01.28.png)

**逻辑地址结构**

<img src="/Users/ryan/Documents/notes/images/os/截屏2022-02-21 下午2.02.17.png" alt="截屏2022-02-21 下午2.02.17" style="zoom: 25%;" />

**段表**

![截屏2022-02-21 下午2.06.39](/Users/ryan/Documents/notes/images/os/截屏2022-02-21 下午2.06.39.png)

**地址变换**

![截屏2022-02-21 下午2.10.49](/Users/ryan/Documents/notes/images/os/截屏2022-02-21 下午2.10.49.png)

与分页不同：在步骤4需要检查段内地址是否超过

分段对用户可见，分页对用户不可见

分段更容易实现新的共享保护（不同程序的段可以基址相同，可以共享内存中的同一段）	

#### 段页式管理

![截屏2022-02-21 下午2.31.34](/Users/ryan/Documents/notes/images/os/截屏2022-02-21 下午2.31.34.png)

地址变换的过程

![截屏2022-02-21 下午2.53.30](/Users/ryan/Documents/notes/images/os/截屏2022-02-21 下午2.53.30.png)

## 3.2 虚拟内存管理

### 3.2.1 基本概念

**传统管理方式特征、缺点**：

一次性：作业必须一次性全部装入内存才能开始运行（两个问题：1 作业很大时候不能全部装入内存 2 运行时内存无法容纳所有作业，只有少量作业能运行，多道程序并发度下降。

驻留性：一旦作业被装入内存，就会一直驻留在内存中。在一个时间段内只需访问作业的一小部分数据即可正常运行，内存中驻留大量用不到的数据。

虚拟内存给予==局部性原理==提出

**虚拟内存的定位和特征**

- 程序装入时，将程序中很快会用到的部分装入内存，暂时用不到的留在外存
- 执行过程中，所访问的信息不再内存，由==操作系统==负责将所需信息从外存调入内存，然后继续执行程序
- 若内存空间不够，操作系统负责将内存中暂时用不到的信息换到外存

<img src="/Users/ryan/Documents/notes/images/os/截屏2022-02-22 上午9.34.14.png" alt="截屏2022-02-22 上午9.34.14" style="zoom:50%;" />

特征：多次性；对换性；虚拟性

**如何实现虚拟内存方式**

虚拟内存的实现建立在离散分配的内存管理方式基础上

- 请求分页存储管理
- 请求分段存储管理
- 请求段页式存储管理

操作系统要提供请求掉页（调段）功能，页面置换（段置换）功能

### 3.2.2 请求分页管理方式

<img src="/Users/ryan/Documents/notes/images/os/截屏2022-02-22 上午9.42.36.png" alt="截屏2022-02-22 上午9.42.36" style="zoom: 25%;" />

**缺页中断机构**

缺页中断：请求分页系统中，要访问的页面不在内存，操作系统的缺页中断处理程序处理中断（内中断）

有空闲块：为进程分配一个空闲块

没有空闲块：页面置换算法选择一个页面淘汰

**地址变换**

<img src="/Users/ryan/Documents/notes/images/os/截屏2022-02-22 上午10.43.19.png" alt="截屏2022-02-22 上午10.43.19" style="zoom:50%;" />

### 3.2.3 页面置换算法

- 最佳置换算法（OPT）：选择最长时间内不再被访问的页面

- 先进先出置换算法（FIFO）：淘汰最早进入内存的页面

    Belady异常：为进程分配的物理块数增大时，缺页次数不减反增（只有FIFO会产生Belady异常）

- 最近最久未使用置换算法（LRU）：淘汰最近最久没使用的页面（设置字段t，记录该页面自上次被访问以来经历的时间t）

- 时钟置换算法（CLOCK）：

    ![截屏2022-02-22 上午10.59.24](/Users/ryan/Documents/notes/images/os/截屏2022-02-22 上午10.59.24.png)

- 改进型的时钟置换算法：

    ![截屏2022-02-22 上午11.15.05](/Users/ryan/Documents/notes/images/os/截屏2022-02-22 上午11.15.05.png)

    第一优先级：最近没访问，没修改；

    第二优先级：没访问，修改过；

    第三优先级：访问过，没被修改；

    第四优先级：访问呗，修改过。

### 3.2.4 页面分配策略

**驻留集**：分页存储管理中给进程分配的物理块集合

固定分配、可变分配（驻留集大小是否改变）

局部置换、全剧置换

**从何处调入页面**

![截屏2022-02-22 上午11.35.45](/Users/ryan/Documents/notes/images/os/截屏2022-02-22 上午11.35.45.png)

**抖动（颠簸）现象**

定义：刚刚换出的页面马上要换入内存，刚刚换入的页面又马上要换出内存

原因：分配给进程的物理块不够

**工作集**：在某段时间间隔内，进程实际访问页面的集合

![截屏2022-02-22 上午11.41.10](/Users/ryan/Documents/notes/images/os/截屏2022-02-22 上午11.41.10.png)

# 第四章 文件管理

<img src="/Users/ryan/Documents/notes/images/os/截屏2022-02-22 上午11.42.42.png" alt="截屏2022-02-22 上午11.42.42" style="zoom:67%;" />

## 4.1 文件系统基础

### 4.1.1 文件的概念

**属性**：

- 文件名
- 标识符（一个系统内的各文件标识唯一）
- 类型
- 位置（文文件存放的鹿筋、对外存中的地址：用户不可见）
- 大小
- 创建时间、上次修改时间、文件所有者信息
- 保护信息

### 4.1.2 文件的逻辑结构

无结构文件：文件内部的数据就是一系列二进制流或字符流组成。又称“流式文件”（.txt文件)

有结构文件：由一组相似的记录组成，“记录式文件”，每条记录由若干个数据项组成。一般每条记录有一个数据项可作为关键字。各条记录的长度是否相等，分为定长记录和可变长记录

**有结构的逻辑机构**

- 顺序文件：文件中的记录一个接一个顺序排列（逻辑上），定长或可变长。
    物理上：顺序存储或链式存储
    - 串结构：记录之间的顺序与关键字无关（按照记录存入的时间决定）
    - 顺序结构：记录之间的顺序按关键字顺序排列
- 索引文件：建立索引表以加快文件检索速度。每条记录对应一个索引项（定长记录的顺序文件）
- 索引顺序文件：建立索引表，但与索引表不同，不是每个记录对应一个索引表项，而是一组记录对应一个索引表项

### 4.1.3 文件目录

**文件控制块（FCB）**：存放控制文件需要的各种信息的数据结构，一个FCB就是一个文件目录项

对目录需要执行的操作：

- 搜索
- 创建文件
- 删除文件
- 显示目录
- 修改目录

目录结构：

- 单级目录结构
    ![截屏2022-02-22 下午2.16.24](/Users/ryan/Documents/notes/images/os/截屏2022-02-22 下午2.16.24.png)
- 两级目录结构
    ![截屏2022-02-22 下午2.17.10](/Users/ryan/Documents/notes/images/os/截屏2022-02-22 下午2.17.10.png)
- 多级目录结构（树形目录结构）
    ![截屏2022-02-22 下午2.18.21](/Users/ryan/Documents/notes/images/os/截屏2022-02-22 下午2.18.21.png)

- 无环图目录结构
    ![截屏2022-02-22 下午2.20.36](/Users/ryan/Documents/notes/images/os/截屏2022-02-22 下午2.20.36.png)

**索引结点**

检索文目录时，只用到文件名，仅当找到一个目录项时，才从该目录项中读出该文件的物理地址，检索目录时文件的其他描述信息不会用到也不需要调入内存，可以吧文件名和文件描述信息分开，文件描述信息单独形成一个数据结构：索引结点。由于目录项的长度减小，因此每个磁盘块可以存放更多个目录项，检索文件时磁盘 I/O 次数少了很多

<img src="/Users/ryan/Documents/notes/images/os/截屏2022-02-22 下午2.27.14.png" alt="截屏2022-02-22 下午2.27.14" style="zoom:33%;" />

### 4.1.4 文件的物理结构

分配方式：

- 连续分配

    要求每个文件在磁盘上占有一组连续的块

    连续分配的文件在顺序 读/写速度最快；拓展不便；存储利用率低，会产生难以利用的磁盘碎片

- 链接分配

    - 隐式链接（只支持顺序访问，不能随机访问）
    - 显式链接：用于链接文件各物理块的指针显式地存放在一张表中，文件分配表（FAT），一个磁盘仅需一个FAT，FAT常驻内存

    ![截屏2022-02-23 上午10.33.27](/Users/ryan/Documents/notes/images/os/截屏2022-02-23 上午10.33.27.png)

- 索引分配
    允许文件离散的分配在各个磁盘块，系统为每个文件建立一张索引表，记录文件的各个逻辑块对应的物理块。
    索引表存放的磁盘块称为==索引块==，文件数据存放的磁盘块称为==数据块==。可以随机访问和文件拓展，索引表会占用一定的存储空间
    多层索引
    混合索引
    ![截屏2022-02-23 上午10.47.18](/Users/ryan/Documents/notes/images/os/截屏2022-02-23 上午10.47.18.png)

### 4.1.5 文件存储空间管理

对空闲磁盘块的管理

**空闲表法**（适用于“连续分配方式”）

![截屏2022-02-23 上午10.52.51](/Users/ryan/Documents/notes/images/os/截屏2022-02-23 上午10.52.51.png)

**空闲链表法**

![截屏2022-02-23 上午10.54.52](/Users/ryan/Documents/notes/images/os/截屏2022-02-23 上午10.54.52.png)

**空闲盘块链：**

- 操作系统保存==链头、链尾==指针
- 如何分配：某文件申请K个盘块，从链头开始一次摘下K个盘块分配，并修改空闲链的链头指针
- 如何回收：回收的盘块依次挂到链尾，并修改空闲链的链尾指针
- 适用于离散分配的物理结构。为文件分配时可能要重复多次操作

**空闲盘区链**

- 保存链头链尾指针
- 如何分配：若某个文件申请K个盘块，从链头开始检索，按照算法规则找到一个符合大小的空闲盘区。若没有合适的，可以将不同盘区的盘块同时分配给一个文件，分配后要修改相应的链指针、盘区大小
- 如何回收：若回收区和某个空闲盘区相邻，需要将回收区合并到空闲盘区；如果没有，将回收区作一个新的空闲盘区挂到链尾。
- 离散和连续分配都适用。为一个文件分配多个盘块时效率更高

**位示图法**

![截屏2022-02-23 上午11.22.03](/Users/ryan/Documents/notes/images/os/截屏2022-02-23 上午11.22.03.png)

- 如何分配：
    需要K个块：
    顺序扫描位示意图，找到K个相邻或不相邻的 0；根据字号、位号算对应的盘块号，将相应盘块分配给文件；相应位设置为 1.
- 如何回收：
    根据回收的盘块号计算相应的字号、位号；设0

**成组链接法**

把顺序的 n 个空闲区地址保存在第一个空闲区中，其后的一个空闲区内则保存另一顺序空闲区的地址，如此继续，直至所有空闲扇区予以链接，系统只保存一个指向第一个空闲扇区的指针

![截屏2022-02-23 下午1.05.35](/Users/ryan/Documents/notes/images/os/截屏2022-02-23 下午1.05.35.png)

如何分配？

![截屏2022-02-23 下午1.07.57](/Users/ryan/Documents/notes/images/os/截屏2022-02-23 下午1.07.57.png)

如何回收？

 ![截屏2022-02-23 下午1.09.48](/Users/ryan/Documents/notes/images/os/截屏2022-02-23 下午1.09.48.png)

### 4.1.6 文件的基本操作

![截屏2022-02-23 下午2.15.21](/Users/ryan/Documents/notes/images/os/截屏2022-02-23 下午2.15.21.png)

### 4.1.7 文件共享 

**基于索引结点的共享方式（硬链接）**

**基于符号链的共享方式（软连接）** （例：快捷方式）

### 4.1.8 文件保护

**口令保护**

**加密保护**

![截屏2022-02-23 下午2.29.37](/Users/ryan/Documents/notes/images/os/截屏2022-02-23 下午2.29.37.png)

**访问控制**

在每个文件的FCB中增加一个访问控制表（ACL），该表记录了各个用户可以对该文件执行哪些操作。建立 **精简的访问控制表**可以降低复杂度，以组为单位。

### 4.1.9 文件系统的层次结构

![截屏2022-02-23 下午2.45.32](/Users/ryan/Documents/notes/images/os/截屏2022-02-23 下午2.45.32.png)

## 4.2 磁盘的组织和管理

### 4.2.1 磁盘的结构

![截屏2022-02-24 下午8.25.35](/Users/ryan/Documents/notes/images/os/截屏2022-02-24 下午8.25.35.png)

### 4.2.2 磁盘调度算法

- 先来先服务 （FCFS）：先到先得
- 最短寻找时间有限 （SSTF）：优先响应距离磁头最近的磁道访问请求
- 扫描算法 （SCAN）：只有磁头移动到最边缘时才可以改变磁头移动方向
- 循环扫描（S-SCAN）：只有磁头向某个方向移动时才会响应请求，移动到边缘后立即让磁头返回起点，中途不响应任何请求
- LOOK算法：改进SCAN和S-SCAN，只要磁头移动方向傻姑娘不再有请求，就立即改变刺头方向

**减少磁盘延迟的方法**

一次读/写操作需要的时间：

- 寻找时间：启动磁臂、移动磁头所花的时间
- 延迟时间：将目标扇区赚到磁头下面花的时间
- 传输时间：读/写数据花费的时间

减少延迟时间的方法：交替编号

![截屏2022-02-24 下午8.47.54](/Users/ryan/Documents/notes/images/os/截屏2022-02-24 下午8.47.54.png)

减少延迟的方法：错位命名

![截屏2022-02-24 下午8.59.41](/Users/ryan/Documents/notes/images/os/截屏2022-02-24 下午8.59.41.png)

### 4.2.3 磁盘管理

**磁盘初始化**

![截屏2022-02-24 下午9.02.16](/Users/ryan/Documents/notes/images/os/截屏2022-02-24 下午9.02.16.png)

**引导块**

![截屏2022-02-24 下午9.11.01](/Users/ryan/Documents/notes/images/os/截屏2022-02-24 下午9.11.01.png)

**坏块的管理**

![截屏2022-02-24 下午9.12.12](/Users/ryan/Documents/notes/images/os/截屏2022-02-24 下午9.12.12.png)

# 第五章 输入/输出设备（I/O）管理

![截屏2022-02-24 下午9.13.08](/Users/ryan/Documents/notes/images/os/截屏2022-02-24 下午9.13.08.png)

## 5.1 I/O 管理概述

### 5.1.1 I/O 设备

**I/O设备就是可以将数据输入计算机或可以接受计算机输出数据的外部设备，属于计算机中的硬件部分。**

unix系统将外部设备抽象为一种特殊的文件，用户可以使用write，read操作对外部设备进行读写，和文件的操作方式相同

按使用特性分类：

- 人机交互外部设备（鼠标、键盘）
- 存储设备（移动硬盘）
- 网络通信设备（调制解调器）

按传输速率分类：

- 低速设备
- 中速设备
- 高速设备

按信息交换的单位分类：

- 块设备：磁盘，数据传输的基本单位是“块”，传输速率高，可寻址，可随机地读/写任一块
- 字符设备：鼠标键盘，速率慢，不可寻址

### 5.1.2 I/O 控制器

功能： 

- 接受和识别CPU发出的命令（**控制寄存器**）
- 向CPU报告设备状态（**状态寄存器**）
- 数据交换（**数据寄存器**）
- 地址识别（类似内存的地址，为区分设备控制器中的各个寄存器，也需要给各个寄存器设置一个特定的地址。I/O 控制器通过CPU提供的“地址”来判断CPU要读/写哪个寄存器

**I/O控制器的组成**

![截屏2022-02-25 上午10.32.31](/Users/ryan/Documents/notes/images/os/截屏2022-02-25 上午10.32.31.png)

- 一个I/O 控制器可能会对应多个设备
- 数据寄存器、控制寄存器可能有多个（每个控制/状态寄存器对应一个具体的设备），这些寄存器都要有相应的地址才能方便CPU操作。
- 有的计算机会让这些寄存器占用内存地址的一部分，称为==内存映像==（可以采用对内存的操作指令来对控制器进行操作）；另一些计算机则采用I/O 专门地址，==寄存器独立编制==（缺点：需要设置专门指令来操作控制器）

### 5.1.3 I/O 控制方式

![截屏2022-02-25 上午10.42.46](/Users/ryan/Documents/notes/images/os/截屏2022-02-25 上午10.42.46.png)

**程序直接控制方式**

- 完成一次读/写操作的流程（轮询）：

    <img src="/Users/ryan/Documents/notes/images/os/截屏2022-02-25 上午11.09.50.png" alt="截屏2022-02-25 上午11.09.50" style="zoom: 50%;" />

- CPU干预的频率：很频繁，需要不断轮询
- 数据传送的单位：每次读/写一个字
- 数据的流向：
    - 读数据（数据输入）：I/O设备 -> CPU -> 内存
    - 写数据（数据输出）：内存 -> CPU -> I/O设备
- 优缺点：
    - 优点：实现简单
    - 缺点：CPU 和 I/O设备智能串行工作，CPU需要一直轮询检查，长期处于“忙等”状态，CPU利用率低。

**中断驱动方式**

- 完成一次读/写操作的流程：

<img src="/Users/ryan/Documents/notes/images/os/截屏2022-02-25 上午11.17.34.png" alt="截屏2022-02-25 上午11.17.34" style="zoom:50%;" />

​	引入中断机制，由于I/O 设备速度慢，因此CPU发出读/写命令后，可以将==等待I/O 进程堵塞==，显切换到别	的进程执行，当I/O 完成后，控制器向CPU发送一个==中断信号==，CPU检测到中断信号后，会保存当前进程	运行环境信息，转去执行中断处理程序处理中断。处理中断中，CPU从 I/O 控制器读**一个字**的数据传送到	CPU寄存器，再写入主存。接着，CPU恢复等待I/O的进程的运行环境，再继续执行。

-  CPU干预频率：每次I/O操作开始之前，之后需要CPU介入
- 数据传送的单位：每次读/写一个字
- 数据的流向：
    - 读数据（数据输入）：I/O设备 -> CPU -> 内存
    - 写数据（数据输出）：内存 -> CPU -> I/O设备
- 优缺点：
    - 优点：CPU和I/O设备可以并行工作
    - 缺点：每个字在I/O设备与内存之间的传输都需要经过CPU，频繁的中断处理会消耗较多的CPU时间。

**DMA方式**（直接存储器存储）

改进：数据传送单位是“**块**”；数据流向是从设备直接放入内存，或者从内存直接到设备；仅在传送一个或多个数据块的开始和结束时，才需要CPU干预。

<img src="/Users/ryan/Documents/notes/images/os/截屏2022-02-25 上午11.34.37.png" alt="截屏2022-02-25 上午11.34.37" style="zoom:50%;" />

DMA 控制器：

![截屏2022-02-25 上午11.39.47](/Users/ryan/Documents/notes/images/os/截屏2022-02-25 上午11.39.47.png)

- CPU干预频率：仅在传送一个或多个数据块开始和结束时，才需要CPU干预
- 数据传送单位：每次读/写一个或多个块（每次读写只能是连续的多个块，这些块在读入内存后在内存中也必须是连续的）
- 数据流向（不用经过CPU）
    - 读操作： I/O 设备 -> 内存
    - 写操作： 内存 -> I/O 设备
- 优缺点：
    - 优点：块为单位，CPU介入频率低
    - 缺点：只能读/写一个或多个连续的数据块，读取离散存储的数据块，要发出多条I/O指令，进行多次中断处理才能完成。

**通道控制方式**

通道可以识别并执行一系列==通道指令==

![截屏2022-02-25 上午11.47.12](/Users/ryan/Documents/notes/images/os/截屏2022-02-25 上午11.47.12.png)

- 完成一次读/写操作：

    <img src="/Users/ryan/Documents/notes/images/os/截屏2022-02-25 上午11.48.03.png" alt="截屏2022-02-25 上午11.48.03" style="zoom:50%;" />

- CPU干预频率：极低，只有完成一组数据块的读/写才需要发出中断，请求CPU干预
- 数据传送单位：每次读/写==一组数据块==
- 数据流向（在通道的控制下进行）
    - 读操作： I/O 设备 -> 内存
    - 写操作： 内存 -> I/O 设备
- 优缺点：
    - 优点：CPU、I/O设备、通道可以并行工作，资源利用率高
    - 缺点：实现复杂，需要专门的通道硬件支持

### 5.1.4 I/O 软件层次结构

![截屏2022-02-25 下午1.28.43](/Users/ryan/Documents/notes/images/os/截屏2022-02-25 下午1.28.43.png)

- 用户层软件
    - 用户层==实现了与用户交互的借口==
    - 向上层提供库函数，下层提供的系统调用

- 设备独立性软件，与设备的硬件特性无关的功能几乎都在这一层实现

    - 向上层提供统一的调用接口（read/write 系统调用）
    - 设备的保护
    - 差错处理
    - 设备的分配和回收
    - 数据缓冲区管理
    - 建立逻辑设备名到物理设备名的映射关系；根据设备类型调用相应的驱动程序
    - 设备独立性软件需要通过“逻辑设备表（LUT）”来确定逻辑设备对应的物理设备，并找到设备对应的设备驱动程序

- 设备驱动程序：

    - 负责对硬件设备的具体控制，将上层发的一系列指令转换为特定设备“能听得懂”的一系列操作。（设置设备寄存器、检查设备状态）
    - 驱动程序一般会以一个单独的进程表示

- 中断处理程序：

    ![截屏2022-02-25 下午1.55.32](/Users/ryan/Documents/notes/images/os/截屏2022-02-25 下午1.55.32.png)

## 5.2 I/O核心子系统

### 5.2.1 I/O子系统概述

I/O核心子系统要实现的功能就是中间三层要实现的功能

![截屏2022-02-25 下午2.01.19](/Users/ryan/Documents/notes/images/os/截屏2022-02-25 下午2.01.19.png)

### 5.2.2 假脱机技术（SPOOLing技术）

**脱机技术及解决的问题**

批处理阶段引入脱机输入/输出技术（磁带完成），在外围控制机的控制下，慢速输入设备的数据先被输入到更快速的磁带上。之后主机可以从快速的磁带上读入数据，从而缓解了速度矛盾。

脱机：脱离主机的控制进行输入/输出操作。

解决问题：即使CPU在忙碌，也可以提前将数据输入到磁带，即使慢速的输出设备正在忙碌，也可以提前将数据输出到磁带。

**假脱机技术**

用软件的方式模拟脱机技术

**输入井和输出井**

![截屏2022-02-25 下午2.10.34](/Users/ryan/Documents/notes/images/os/截屏2022-02-25 下午2.10.34.png)

输入进程：模拟脱机输入时的外围控制机

输出进程：模拟脱机输出的外围控制机

输入缓冲区和输出缓冲区是在内存中的缓冲区

**共享打印机原理分析**

独占式设备：==只允许各个进程串行使用的设备==，一段时间内只能满足一个进程的请求

共享设备：==允许多个进程“同时”使用的设备==，宏观上同时使用，微观上可能是交替使用

![截屏2022-02-25 下午2.23.18](/Users/ryan/Documents/notes/images/os/截屏2022-02-25 下午2.23.18.png)

虽然只有一台打印机，但每个进程提出打印请求，系统都会为在输出井中为其分配一个存储区（相当于分配了一个逻辑设备），每个用户进程都觉得自己在独占一台打印机，实现了对打印机的共享。

### 5.2.3 设备的分配与回收

**设备分配时应考虑的因素**

- 设备固有属性
- 设备分配算法
- 设备分配中的安全性

**静态分配和动态分配**

**设备分配管理中的数据结构**

设备控制表（DCT）：系统为每个设备配置一张DCT，用于记录设备情况

控制器控制表（COCT）

通道控制表（CHCT）

设备记录表（SDT）

**设备分配的步骤**

![截屏2022-02-25 下午2.52.12](/Users/ryan/Documents/notes/images/os/截屏2022-02-25 下午2.52.12.png)

逻辑设备表（LUT）：建立了逻辑设备名与物理设备名之间的映射关系

### 5.2.4 缓冲区管理

缓冲区即一个存储区域，可以由专门的硬件寄存器组成，也可以利用内存作为缓冲区

**缓冲区作用：**

- 缓和CPU和 I/O 设备之间速度不匹配的矛盾；
- 减少对CPU的中断频率，放宽对CPU中断响应时间的限制
- 解决数据粒度不匹配的问题
- 提高CPU 与 I/O 设备之间的并行性

**单缓冲**

缓冲区数据非空时，不能往缓冲区冲入数据，只能从过年缓冲区把数据拿出来；当缓冲区为空时，可以往缓冲区冲入数据，但必须把缓冲区充满，才能从缓冲区把数据传出

![截屏2022-02-25 下午3.57.28](/Users/ryan/Documents/notes/images/os/截屏2022-02-25 下午3.57.28.png)

**双缓冲**

**单缓冲、双缓冲在通信时区别**

![截屏2022-02-25 下午4.00.26](/Users/ryan/Documents/notes/images/os/截屏2022-02-25 下午4.00.26.png)

![截屏2022-02-25 下午4.00.46](/Users/ryan/Documents/notes/images/os/截屏2022-02-25 下午4.00.46.png)

 **循环缓冲区**

![截屏2022-02-25 下午4.01.47](/Users/ryan/Documents/notes/images/os/截屏2022-02-25 下午4.01.47.png)

**缓冲池**：系统中共用的缓冲区组成

按使用状况分：

- 空缓冲队列
- 装满输入数据的缓冲队列（输入队列）
- 装满输出数据的缓冲队列（输出队列）

一个缓冲区在实际运算中扮演的功能不同，设置四种工作缓冲区：

- 用于收容输入数据的工作缓冲区（hin）
- 用于提取输入数据的工作缓冲区（sin）
- 用于收容输出数据的工作缓冲区（hout）
- 用于提取输出数据的工作缓冲区（sout）

<img src="/Users/ryan/Documents/notes/images/os/截屏2022-02-25 下午4.06.13.png" alt="截屏2022-02-25 下午4.06.13" style="zoom: 50%;" />